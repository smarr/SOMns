class Savina usingPlatform: platform andHarness: harness = Value (
| private Benchmark = harness Benchmark.
  private actors    = platform actors.
  private Array     = platform kernel Array.
  private Vector    = platform kernel Vector.
  private Dictionary= platform collections Dictionary.
  private system    = platform system.
|
)(
  (* A simple PRNG, to be as portable as possible. *)
  public class Random new: seed = (
    | private seed ::= seed.
      private gotNextGaussian  ::= false.
      private nextNextGaussian ::= 0.0. |
  ) (
    public next = (
      seed := ((seed * 1309) + 13849) & 65535.
      ^ seed
    )
    
    (* Returns an integer within the range of [0, bound) *)
    public next: bound = (
      ^ next % bound
    )
    
    (* Returns a double uniformly distributed in the range of [0.0, 1.0) *)
    public nextDouble = (
      ^ next // 65536
    )
    
    public nextBoolean = (
      ^ next < 32768
    )
    
    (* Returns a double normally distributed with mean 0.0 
       and standard deviation of 1.0 *)
    public nextGaussian = (
      | v1 v2 s multiplier |
      gotNextGaussian ifTrue: [
        gotNextGaussian := false.
        ^ nextNextGaussian ].
      
      v1 := (2.0 * nextDouble) - 1.0.
      v2 := (2.0 * nextDouble) - 1.0.
      s  := (v1 * v1) + (v2 * v2).
      
      [s >= 1.0 or: [s = 0.0]] whileTrue: [
        v1 := (2.0 * nextDouble) - 1.0.
        v2 := (2.0 * nextDouble) - 1.0.
        s  := (v1 * v1) + (v2 * v2).
      ].
      
      multiplier := (-2.0 * s log // s) sqrt.
      nextNextGaussian := v2 * multiplier.
      gotNextGaussian := true.
      ^ v1 * multiplier
    )
  ) : (
    public new = (
      ^ new: 74755
    )
  )

  (* === Savina Microbenchmarks === *)
  
  public class PingPong new: numPings = Benchmark <: Value (
  | private NumPings = numPings.
  |
  )(
    class Ping new: cnt with: pong = (
      | private pingsLeft ::= cnt.
        private pong = pong.
      |
    ) (
      public start = (
        pong <-: ping: self.
        pingsLeft := pingsLeft - 1.
      )
    
      public ping = (
        pong <-: ping: self.
        pingsLeft := pingsLeft - 1.
      )
    
      public pong: sender = (
        pingsLeft > 0
          ifTrue:  [ self <-: ping ]
          ifFalse: [ pong <-: stop ].
      )
    )
  
    class Pong new: completionRes = (
    | private pongCount ::= 0.
      private completionRes = completionRes.
    |
    ) (
      public ping: sender = (
        sender <-: pong: self.
        pongCount := pongCount + 1.
      )
    
      public stop = (
        completionRes resolve: pongCount
      )
    )
    
    public benchmark = (
      | ping pong completionPP |
      completionPP := actors createPromisePair.
      pong := (actors createActorFromValue: Pong) <-: new: completionPP resolver.
      ping := (actors createActorFromValue: Ping) <-: new: NumPings with: pong.
      ping <-: start.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      ^ result = NumPings
    )
  ) : (
    public newInstance: problemSize = ( ^ self new: problemSize asInteger )
    public setupVerifiedRun: run = ( run problemSize: 1 )
  )

  public class Counting new: limit = Benchmark <: Value (
  | private limit = limit. |
  )(
    public class ProducerActor new: counter resolver: completionRes = (
    | private counter = counter.
      private completionRes = completionRes.
    |
    )(
      public increment = (
        1 to: limit do: [:i |
          counter <-: increment ].
        
        counter <-: requestCount: self.
      )
      
      public count: cnt = (
        completionRes resolve: cnt = limit
      )
    )
    
    public class CountingActor = (
    | private count ::= 0. |
    ) (
      public increment = (
        count := count + 1.
      )
      
      public requestCount: requester = (
        requester <-: count: count
      )
    )
  
    public benchmark = (
      | counter producer completionPP |
      completionPP := actors createPromisePair.
      counter  := (actors createActorFromValue: CountingActor) <-: new.
      producer := (actors createActorFromValue: ProducerActor) <-: new: counter resolver: completionPP resolver.
      producer <-: increment.

      ^ completionPP promise
    )
    
    public verifyResult: isCorrect = (
      ^ isCorrect
    )
  ) : (
    public newInstance: problemSize = ( ^ self new: problemSize asInteger )
    public setupVerifiedRun: run = ( run problemSize: 10000 )
  )

  public class ForkJoinThroughput new: numActors  totalMessages: numMessages = Benchmark <: Value (
  | private numActors    = numActors.
    private numMessages  = numMessages.
  |
  )(
    class ThroughputActor new: completionResolver = (
    | private messagesProcessed  ::= 0.
      private completionResolver = completionResolver.
    |
    )(
      private performComputation: theta = (
        | sint res |
        sint := theta sin.
        res := sint * sint.
        
        (* defeat dead code elimination *)
        res <= 0.0 ifTrue: [
          system error: 'Benchmark calculated unrealistic res value ' + res asString ]
      )
     
      public process = (
        messagesProcessed := messagesProcessed + 1.
        self performComputation: 37.2.
        
        messagesProcessed = numMessages ifTrue: [
          completionResolver resolve: messagesProcessed
        ]
      )
    )
  
    public benchmark = (
      | benchActors promiseGroup |
      promiseGroup := nil.
      benchActors := Array new: numActors withAll: [
        | promisePair |
        promisePair := actors createPromisePair.
        promiseGroup
          ifNil:    [ promiseGroup := promisePair promise ]
          ifNotNil: [ promiseGroup := promiseGroup, promisePair promise ].
        (actors createActorFromValue: ThroughputActor) <-: new: promisePair resolver
      ].
      
      numMessages timesRepeat: [
        benchActors do: [:a | a <-: process ] ].
      
      ^ promiseGroup
    )
    
    public verifyResult: result = (
      result do: [:n | n = numMessages ifFalse: [ ^ false ] ].
      ^ true
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self new: (problem at: 1) asInteger
         totalMessages: (problem at: 2) asInteger
    )
    public setupVerifiedRun: run = ( run problemSize: '100:1000' )
  )

  public class ForkJoinActorCreation new: numActors = Benchmark <: Value (
  | private numActors = numActors. |
  )(
    class ForkJoinActor new: completionResolver = (
      completionResolver resolve: (performComputation: 37.2)
    )()
    
    private performComputation: theta = (
      | sint res |
      sint := theta sin.
      res := sint * sint.

      res <= 0.0 ifTrue: [
        system error: 'Benchmark calculated unrealistic res value ' + res asString ].
      ^ res
    )
  
    public benchmark = (
      | promiseGroup |
      promiseGroup := nil.
      
      numActors timesRepeat: [
        | promisePair |
        promisePair := actors createPromisePair.
        promiseGroup
          ifNil:    [ promiseGroup := promisePair promise ]
          ifNotNil: [ promiseGroup := promiseGroup, promisePair promise ].
        (actors createActorFromValue: ForkJoinActor) <-: new: promisePair resolver.
      ].
      ^ promiseGroup
    )
    
    public verifyResult: resultVector = (
      | expResult |
      expResult := performComputation: 37.2.
      resultVector do: [:r | r = expResult ifFalse: [ ^ false ] ].
      ^ true
    )
  ) : (
    public newInstance: problemSize = ( ^ self new: problemSize asInteger )
    public setupVerifiedRun: run = ( run problemSize: 1 )
  )
  
  public class ThreadRing new: numActors numPings: numPings = Benchmark <: Value(
  | private numActors = numActors.
    private numPings  = numPings.
  |
  )(
    class ThreadRingActor new: id resolver: completionRes = (
    | private id = id.
      private nextAct ::= nil.
      private completionRes = completionRes.
    |
    )(
      public ping: t = (
        t > 0 ifTrue: [
          nextAct <-: ping: t - 1
        ] ifFalse: [
          nextAct <-: exit: numActors - 1
        ]
      )
      
      public exit: t = (
        t > 0 ifTrue: [
          nextAct <-: exit: t - 1
        ] ifFalse: [
          completionRes resolve: id.
        ]
      )
      
      public nextActor: actor = (
        nextAct := actor
      )
    )
    
    public benchmark = (
      | threadActors completionPP |
      completionPP := actors createPromisePair.
      threadActors := Array new: numActors.
      1 to: numActors do: [:i |
        | threadActor |
        threadActor := (actors createActorFromValue: ThreadRingActor) <-: new: i resolver: completionPP resolver.
        threadActors at: i put: threadActor.
      ].
      
      1 to: numActors do: [:i |
        | nextActor |
        nextActor := threadActors at: (i % numActors) + 1.
        (threadActors at: i) <-: nextActor: nextActor.
      ].
      
      (threadActors at: 1) <-: ping: numPings.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      ^ result = 1
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self new: (problem at: 1) asInteger
        numPings: (problem at: 2) asInteger
    )
    public setupVerifiedRun: run = ( run problemSize: '30:300' )
  )
  
  public class Chameneos meetings: numMeetings chameneos: numChameneos = Benchmark <: Value (
  | private numMeetings  = numMeetings.
    private numChameneos = numChameneos.
    
    private red    = Red    new.
    private yellow = Yellow new.
    private blue   = Blue   new.
    private faded  = Faded  new.
  |
  )(
    class Red = Value ()(
      public complement: other = ( ^ other redComplement )
      public redComplement     = ( ^ red    )
      public yellowComplement  = ( ^ blue   )
      public blueComplement    = ( ^ yellow )
    )
    class Yellow = Value ()(
      public complement: other = ( ^ other yellowComplement )
      public redComplement     = ( ^ blue   )
      public yellowComplement  = ( ^ yellow )
      public blueComplement    = ( ^ red    )
    )
    class Blue = Value ()(
      public complement: other = ( ^ other blueComplement )
      public redComplement     = ( ^ yellow )
      public yellowComplement  = ( ^ red    )
      public blueComplement    = ( ^ blue   )
    )
    class Faded = Value ()(
      public complement: other = ( ^ faded )
    )
  
    class ChameneosMallActor new: completionRes = (
    | private waitingChameneo ::= nil.
      private sumMeetings     ::= 0.
      private numFaded        ::= 0.
      private n               ::= numMeetings.
      private completionRes   = completionRes.
    |
      start.
    )(
      private color: anInt = (
        | colorIdx |
        colorIdx := anInt % 3.
        colorIdx = 0 ifTrue: [ ^ red    ].
        colorIdx = 1 ifTrue: [ ^ yellow ].
        colorIdx = 2 ifTrue: [ ^ blue   ].
      )

      private start = (
        0 to: numChameneos - 1 do: [:i |
          | color |
          color := color: i.
          (actors createActorFromValue: ChameneosChameneoActor) <-: new: self color: color
        ]
      )

      public meetingCount: count = (
        numFaded := numFaded + 1.
        sumMeetings := sumMeetings + count.
        numFaded = numChameneos ifTrue: [ completionRes resolve: sumMeetings ]
      )
      
      public meet: sender color: color = (
        n > 0 ifTrue: [
          waitingChameneo
            ifNil: [ waitingChameneo := sender ]
            ifNotNil: [
              n := n - 1.
              waitingChameneo <-: meet: sender color: color.
              waitingChameneo := nil.
            ]
        ] ifFalse: [
          sender <-: exit: self
        ]
      )
    )
    
    class ChameneosChameneoActor new: mall color: color = (
    | private mall       = mall.
      private color    ::= color.
      private meetings ::= 0.
    |
      start.
    )(
      private start = (
        mall <-: meet: self color: color.
      )

      public meet: sender color: otherColor = (
        | complement |
        complement := color complement: otherColor.
        meetings := meetings + 1.
        sender <-: change: color.
        mall   <-: meet: self color: color.
      )
      
      public change: newColor = (
        color := newColor.
        meetings := meetings + 1.
        mall <-: meet: self color: newColor.
      )
      
      public exit: sender = (
        color := faded.
        sender <-: meetingCount: meetings
      )
    )
    
    public benchmark = (
      | mallActor completionPP |
      completionPP := actors createPromisePair.
      mallActor := (actors createActorFromValue: ChameneosMallActor) <-: new: completionPP resolver.
      ^ completionPP promise
    )
    
    public verifyResult: sumMeetings = (
      ^ sumMeetings = (2 * numMeetings)
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self meetings: (problem at: 1) asInteger
            chameneos: (problem at: 2) asInteger
    )
    public setupVerifiedRun: run = ( run problemSize: '100:200000' )
  )
  
  public class Big = Benchmark ()( todo = () )
  (* === Savina Concurrency Benchmarks === *)

  public class ConcurrentDictionary numEntities: numEntities numMessages: numMessages writePercentage: writePercentage = Benchmark <: Value (
  | private numMessages = numMessages.
    private numEntities = numEntities.
    private writePercentage = writePercentage.
    private dataLimit = 512. (* 524287 / 1024,  Integer.MAX_VALUE / 4_096 TODO: this is not the same constant as originally! *)
  |
  )(
    class Master new: completionRes = (
    | private workers    = Array new: numEntities.
      private dictionary = (actors createActorFromValue: DictionaryActor) <-: new: completionRes.
      private numWorkersTerminated ::= 0.
    |
      start.
    )(
      private start = (
        workers doIndexes: [:i |
          | worker |
          worker := (actors createActorFromValue: Worker) <-: new: self dict: dictionary id: i.
          workers at: i put: worker.
          worker <-: doWork.
        ]
      )
      
      public endWork = (
        numWorkersTerminated := numWorkersTerminated + 1.
        numWorkersTerminated = numEntities ifTrue: [
          dictionary <-: endWork.
        ]
      )
    )
    
    class Worker new: master dict: dictionary id: id = (
    | private messageCount ::= 0.
      private random = Random new: id + numMessages + writePercentage.
      private master = master.
      private dictionary = dictionary.
    |
    )(
      public doWork = (
        messageCount := messageCount + 1.
        messageCount <= numMessages
          ifTrue: [
            | rnd |
            rnd := random next % 100.
            rnd < writePercentage
              ifTrue:  [ dictionary <-: write: self key: random next % dataLimit value: random next ]
              ifFalse: [ dictionary <-: read: self key: random next % dataLimit ] ]
          ifFalse: [ master <-: endWork ].
      )
      
      public result: value = (
        self doWork
      )
    )
    
    class DictionaryActor new: completionRes = (
    | private dataMap = self createDataMap: dataLimit.
      private completionRes = completionRes.
    |
    )(
      private createDataMap: dataLimit = (
        | dict |
        dict := Dictionary new: dataLimit.
        0 to: dataLimit - 1 do: [:i |
          dict at: i put: i
        ].
        ^ dict
      )
      
      public write: sender key: key value: val = (
        dataMap at: key put: val.
        sender <-: result: val
      )
      
      public read: sender key: key = (
        sender <-: result: (dataMap at: key)
      )
      
      public endWork = (
        completionRes resolve: dataMap size
      )
    )
  
    public benchmark = (
      | master completionPP |
      completionPP := actors createPromisePair.
      master := (actors createActorFromValue: Master) <-: new: completionPP resolver.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      ^ result = dataLimit
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self numEntities: (problem at: 1) asInteger
             numMessages: (problem at: 2) asInteger
         writePercentage: (problem at: 3) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '100:100:50'
    )
  )

  public class ConcurrentSortedLinkedList numWorkers: w numMessagesPerWorker: mw writePercentage: wp sizePercentage: sp = Benchmark <: Value (
  | private numWorkers           = w.
    private numMessagesPerWorker = mw.
    private writePercentage      = wp.
    private sizePercentage       = sp.
  |)(
    class Master new: completionRes = (
    | private workers    = Array new: numWorkers.
      private sortedList = (actors createActorFromValue: SortedList) <-: new: completionRes.
      private numWorkersTerminated ::= 0.
    |
      workers doIndexes: [:i |
        workers at: i put: ((actors createActorFromValue: Worker) <-: new: self sortedList: sortedList id: i).
        (workers at: i) <-: doWork.
      ]
    )(
      public endWork = (
        numWorkersTerminated := numWorkersTerminated + 1.
        numWorkersTerminated = numWorkers ifTrue: [
          sortedList <-: endWork
        ]
      )
    )
    
    class Worker new: master sortedList: sortedList id: id = (
    | private master = master.
      private sortedList = sortedList.
      private messageCount ::= 0.
      private random = Random new: id + numMessagesPerWorker + writePercentage + sizePercentage.
    |)(
      public endWork = (
        messageCount := messageCount + 1.
        master <-: endWork.
      )

      public doWork = (
        messageCount := messageCount + 1.
        messageCount <= numMessagesPerWorker
          ifTrue: [
            | anInt |
            anInt := random next % 100.
            anInt < sizePercentage
              ifTrue: [ sortedList <-: size: self.
                        ^ self ].
            anInt < (sizePercentage + writePercentage)
              ifTrue: [ sortedList <-: write: random next sender: self.
                        ^ self].
            sortedList <-: contains: random next sender: self ]
          ifFalse: [
            master <-: endWork
          ]
      )
      
      public result: val = (
        self doWork
      )
    )
    
    class SortedList new: completionRes = (
    | private completionRes = completionRes.
      private dataList = SortedLinkedList new.
    |)(
      public write: anInt sender: sender = (
        dataList add: anInt.
        sender <-: result: anInt
      )
      
      public contains: anInt sender: sender = (
        | result |
        result := dataList contains: anInt.
        sender <-: result: result.
      )
      
      public size: sender = (
        sender <-: result: dataList size
      )
      
      public endWork = (
        completionRes resolve: dataList size
      )
    )
    
    class SortedLinkedList = (
    | private head ::= nil.
      private iterator ::= nil.
    |)(
      class Node new: i = (
      | public item ::= i.
        public next ::= nil.
      |)()
      
      public isEmpty = ( ^ head isNil )
      
      public add: item = (
        | newNode after before |
        newNode := Node new: item.
        head ifNil: [
          head := newNode.
          ^ self ].

        item < head item ifTrue: [
          newNode next: head.
          head := newNode.
          ^ self ].
        
        after  := head next.
        before := head.
        
        [ after notNil and: [ item >= after item] ] whileTrue: [
          before := after.
          after  := after next.
        ].
        
        newNode next: before next.
        before next: newNode.
      )
      
      public contains: item = (
        | n |
        n := head.
        [ n notNil ] whileTrue: [
          item = n item ifTrue: [ ^ true ].
          n := n next.
        ].
        ^ false
      )
      
      public size = (
        | r n |
        r := 0.
        n := head.
        [ n notNil ] whileTrue: [
          r := r + 1.
          n := n next
        ].
        ^ r
      )
    )
  
    public benchmark = (
      | master completionPP |
      completionPP := actors createPromisePair.
      master := (actors createActorFromValue: Master) <-: new: completionPP resolver.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      (numWorkers = 10 and: [numMessagesPerWorker =   20 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result =   18 ].
      (numWorkers = 10 and: [numMessagesPerWorker =  100 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result =  106 ].
      (numWorkers = 10 and: [numMessagesPerWorker =  300 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result =  292 ].
      (numWorkers = 10 and: [numMessagesPerWorker =  500 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result =  476 ].
      (numWorkers = 10 and: [numMessagesPerWorker = 1000 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result =  992 ].
      (numWorkers = 10 and: [numMessagesPerWorker = 1500 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result = 1496 ].
      (numWorkers = 20 and: [numMessagesPerWorker = 1000 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result = 1959 ].
      (numWorkers = 20 and: [numMessagesPerWorker = 2000 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result = 3956 ].
      
      (* otherwise, warn that we don't know whether it is correct. *)
      ('---- result: ' + result asString + ' dont have a hardcoded verification result for this config yet') println.
      ^ false
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self        numWorkers: (problem at: 1) asInteger
          numMessagesPerWorker: (problem at: 2) asInteger
               writePercentage: (problem at: 3) asInteger
                sizePercentage: (problem at: 4) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '20:8000:10:1'
    )
  )

  public class ProducerConsumerBoundedBuffer bufferSize: bs numProducers: np numConsumers: nc numItemsPerProducer: ni = Benchmark <: Value (
  | private bufferSize   = bs.
    private numProducers = np.
    private numConsumers = nc.
    private numItemsPerProducer = ni.
    private prodCost     = 25.
    private consCost     = 25.
  |)(
    class Data new: datum from: sender = Value (
    | public datum  = datum.
      public sender = sender.|)()
    
    class ManagerActor new: completionRes = (
    | private adjustedBufferSize = bufferSize - numProducers.
      private availableProducers = Vector new.
      private availableConsumers = Vector new.
      private pendingData        = Vector new.
      private numTerminatedProducers ::= 0.
      private producers          = Array new: numProducers.
      private consumers          = Array new: numConsumers.
      private completionRes      = completionRes.
      private dataSum ::= 0.0.
    |
      producers doIndexes: [:i |
        | producer |
        producer := (actors createActorFromValue: ProducerActor) <-: new: i manager: self.
        producers at: i put: producer.
        producer <-: produceData.
      ].
      consumers doIndexes: [:i |
        | consumer |
        consumer := (actors createActorFromValue: ConsumerActor) <-: new: i manager: self.
        consumers at: i put: consumer.
        availableConsumers append: consumer.
      ]
    )(
      public data: datum from: producer = (
        dataSum := dataSum + datum.
        availableConsumers isEmpty
          ifTrue:  [ pendingData append: (Data new: datum from: producer) ]
          ifFalse: [ availableConsumers removeFirst <-: data: datum from: producer ].
        
        pendingData size >= adjustedBufferSize
          ifTrue:  [ availableProducers append: producer ]
          ifFalse: [ producer <-: produceData ]
      )
      
      public consume: consumer = (
        pendingData isEmpty
          ifTrue: [
            availableConsumers append: consumer.
            tryExit ]
          ifFalse: [
            | data |
            data := pendingData removeFirst.
            consumer <-: data: data datum from: data sender.
            availableProducers isEmpty ifFalse: [
              availableProducers removeFirst <-: produceData ] ].
      )
      
      public producerExit = (
        numTerminatedProducers := numTerminatedProducers + 1.
        tryExit
      )
      
      private tryExit = (
        (numTerminatedProducers = numProducers and: [availableConsumers size = numConsumers])
          ifTrue: [
            consumers do: [:c | c <-: exit ].
            completionRes resolve: dataSum ].
      )
    )
    
    class ProducerActor new: id manager: manager = (
    | private prodItem ::= 0.0.
      private itemsProduced ::= 0.
      private manager = manager.
    |)(
      private prodData = (
        prodItem := processItem: prodItem cost: prodCost.
        manager <-: data: prodItem from: self.
        itemsProduced := itemsProduced + 1.
      )
      
      public produceData = (
        itemsProduced < numItemsPerProducer
          ifTrue:  [ self prodData ]
          ifFalse: [ manager <-: producerExit ]
      )
    )
    
    class ConsumerActor new: id manager: manager = (
    | private consItem ::= 0.0.
      private manager = manager.
    |)(
      private consumeDataItem: dataToConsume = (
        consItem := processItem: consItem + dataToConsume cost: consCost.
      )
      
      public data: datum from: sender = (
        consumeDataItem: datum.
        manager <-: consume: self
      )
      
      public exit = ()
    )
    
    private processItem: curTerm cost: cost = (
      | res random |
      res    := curTerm.
      random := Random new: cost.
      
      cost > 0
        ifTrue: [
          cost timesRepeat: [
            100 timesRepeat: [
              res := res + (random nextDouble abs + 0.01) log ] ] ]
        ifFalse: [
          res := res + (random nextDouble abs + 0.01) log ].
      ^ res
    )
  
    public benchmark = (
      | manager completionPP |
      completionPP := actors createPromisePair.
      manager := (actors createActorFromValue: ManagerActor) <-: new: completionPP resolver.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      (bufferSize = 40 and: [numProducers = 10 and: [numConsumers = 10 and: [numItemsPerProducer =  60]]]) ifTrue: [^ result round =   -43522486].
      (bufferSize = 40 and: [numProducers = 10 and: [numConsumers = 10 and: [numItemsPerProducer =  80]]]) ifTrue: [^ result round =   -77056204].
      (bufferSize = 40 and: [numProducers = 20 and: [numConsumers = 20 and: [numItemsPerProducer =  80]]]) ifTrue: [^ result round =  -154112409].
      (bufferSize = 50 and: [numProducers = 20 and: [numConsumers = 20 and: [numItemsPerProducer = 100]]]) ifTrue: [^ result round =  -240206069].
      (bufferSize = 50 and: [numProducers = 40 and: [numConsumers = 40 and: [numItemsPerProducer = 100]]]) ifTrue: [^ result round =  -480412139].
      (bufferSize = 40 and: [numProducers = 10 and: [numConsumers = 10 and: [numItemsPerProducer = 600]]]) ifTrue: [^ result round = -4288035081].

      (* otherwise, warn that we don't know whether it is correct. *)
      ('---- result: ' + result asString + ' dont have a hardcoded verification result for this config yet') println.
      ^ false
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      
      ^ self bufferSize: (problem at: 1) asInteger
           numProducers: (problem at: 2) asInteger
           numConsumers: (problem at: 3) asInteger
    numItemsPerProducer: (problem at: 4) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '50:40:40:1000'
    )
  )

  public class Philosophers = Benchmark ()( todo = () )
  public class SleepingBarber = Benchmark ()( todo = ( USE_MATH_RANDOM_WHICH_SEQUENTIALIZES ) )
  public class CigaretteSmokers = Benchmark ()( todo = ( USE_MATH_RANDOM_WHICH_SEQUENTIALIZES ) )
  public class LogisticsMapSeries = Benchmark ()( todo = () )
  public class BankTransaction = Benchmark ()( todo = () )
  
  (* === Savina Parallelism Benchmarks === *)
  
  public class RadixSort numValues: numValues maxValue: maxValue seed: seed = Benchmark <: Value (
  | private numValues = numValues. 
    private maxValue  = maxValue.  (* Needs to be a power of 2, I think *)
    private seed      = seed.      (* Should probably be a prime number *)
  |
  )(
    class IntSourceActor = (
    | private random = Random new: seed. |
    ) (
      public next: actor = (
        1 to: numValues do: [:i |
          | candidate |
          candidate := (random next % maxValue) abs.
          actor <-: value: candidate.
        ]
      )
    )
  
    class SortActor new: radix next: nextActor = (
    | private radix     = radix.
      private next      = nextActor.
      
      private orderingArray = Array new: numValues withAll: 0.
      private valuesSoFar ::= 0.
      private j           ::= 1.
    |
    )(
      public value: current = (
        valuesSoFar := valuesSoFar + 1.
        
        (current & radix) = 0
          ifTrue:  [
           next <-: value: current ]
          ifFalse: [
            orderingArray at: j put: current.
            j := j + 1
          ].
        
        valuesSoFar = numValues ifTrue: [
          1 to: j - 1 do: [:i |
            next <-: value: (orderingArray at: i)
          ].
        ]
      )
    )
    
    class ValidationActor new: completionRes = (
    | private sumSoFar    ::=  0.
      private valuesSoFar ::=  0.
      private prevValue   ::=  0.
      private errorValue  ::= -1.
      private errorIdx    ::= -1.
      private completionRes = completionRes.
    |
    )(
      public value: val = (
        valuesSoFar := valuesSoFar + 1.
        
        (val < prevValue and: [errorValue < 0]) ifTrue: [
          errorValue := val.
          errorIdx   := valuesSoFar.
          system error: 'ERROR: Value out of place: ' + errorValue + ' at index ' + errorIdx
        ].
        
        prevValue := val.
        sumSoFar := sumSoFar + prevValue.
        
        valuesSoFar = numValues ifTrue: [
          errorValue >= 0
            ifTrue:  [ system error: 'Value out of place: ' + errorValue + ' at index ' + errorIdx ].
          completionRes resolve: sumSoFar
        ]
      )
    )
  
    public benchmark = (
      | validationActor sourceActor radix nextActor completionPP |
      completionPP := actors createPromisePair.
      validationActor := (actors createActorFromValue: ValidationActor) <-: new: completionPP resolver.
      sourceActor     := (actors createActorFromValue: IntSourceActor)  <-: new.
      
      radix := maxValue / 2.
      nextActor := validationActor.
      
      [radix > 0] whileTrue: [
        | sortActor |
        sortActor := (actors createActorFromValue: SortActor) <-: new: radix next: nextActor.
        
        radix := radix / 2.
        nextActor := sortActor
      ].
      
      sourceActor <-: next: nextActor.
      
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      (numValues =   100 and: [maxValue =   256 and: [seed = 74755]]) ifTrue: [ ^ result = 13606 ].
      (numValues = 10000 and: [maxValue = 65536 and: [seed = 74755]]) ifTrue: [ ^ result = 329373752 ].
      (numValues = 50000 and: [maxValue = 65536 and: [seed = 74755]]) ifTrue: [ ^ result = 1642300184 ].

      ('---- result: ' + result asString + ' dont have a hardcoded verification result for this config yet') println.
      ^ false
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self numValues: (problem at: 1) asInteger
              maxValue: (problem at: 2) asInteger
                  seed: (problem at: 3) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '100:256:74755'
    )
  )
  
  public class FilterBank = Benchmark ()( todo = () )
  
  public class Sieve new: limit local: numMaxLocalPrimes = Benchmark <: Value (
  | private limit = limit.
    private numMaxLocalPrimes = numMaxLocalPrimes.
  |
  )(
    class NumberProducerActor = ()(
      public produceNumbersFor: filterActor = (
        | candidate |
        candidate := 3.
        [candidate < limit] whileTrue: [
          filterActor <-: filter: candidate.
          candidate := candidate + 2
        ].
        
        filterActor <-: exit.
      )
    )
    
    class PrimeFilterActor new: id initialPrime: initialPrime resolver: completionRes = (
    | private id = id.
      private initialPrime = initialPrime.
      private nextFilterActor ::= nil.
      private localPrimes = Array new: numMaxLocalPrimes withAll: 0.
      private availableLocalPrimes ::= 1.
      private completionRes = completionRes.
    |
      localPrimes at: 1 put: initialPrime.
    )(
      private handleNewPrim: newPrim = (
        availableLocalPrimes < numMaxLocalPrimes
          ifTrue: [
            (* store locally if there is space *)
            availableLocalPrimes := availableLocalPrimes + 1.
            localPrimes at: availableLocalPrimes put: newPrim ]
          ifFalse: [
            (* create a new actor to store a new prime *)
            nextFilterActor := (actors createActorFromValue: PrimeFilterActor)
              <-: new: id + 1 initialPrime: newPrim resolver: completionRes
          ]
      )
      
      private isLocallyPrime: candidate = (
        1 to: availableLocalPrimes do: [:i |
          | remainder |
          remainder := candidate % (localPrimes at: i).
          remainder = 0 ifTrue: [ ^ false ]
        ].
        ^ true
      )
      
      public filter: candidate = (
        (isLocallyPrime: candidate)
          ifTrue: [
            nextFilterActor
              ifNil:    [handleNewPrim: candidate]
              ifNotNil: [nextFilterActor <-: filter: candidate]
          ]
      )
      public exit = (
        nextFilterActor
          ifNil: [
            | totalPrimes |
            totalPrimes := ((id - 1) * numMaxLocalPrimes) + availableLocalPrimes.
            completionPP resolve: totalPrimes ]
          ifNotNil: [ nextFilterActor <-: exit ]
      )
    )
   
    public benchmark = (
      | producerActor filterActor completionPP |
      completionPP := actors createPromisePair.
      producerActor := (actors createActorFromValue: NumberProducerActor) <-: new.
      filterActor   := (actors createActorFromValue: PrimeFilterActor)    <-: new: 1 initialPrime: 2 resolver: completionPP resolver.

      producerActor <-: produceNumbersFor: filterActor.
      
      ^ completionPP promise
    )
    
    public verifyResult: numberOfPrimes = (
      limit = 100    ifTrue: [ ^ numberOfPrimes =   25 ].
      limit = 1000   ifTrue: [ ^ numberOfPrimes =  168 ].
      limit = 10000  ifTrue: [ ^ numberOfPrimes = 1229 ].
      limit = 100000 ifTrue: [ ^ numberOfPrimes = 9592 ].
      (* otherwise, we don't know. *)
      ^ true 
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self new: (problem at: 1) asInteger
           local: (problem at: 2) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '100000:64'
    )
  )
  
  (* Compared to the Savina original benchmarks, this does not contain code for
     'urgent' nodes, which seemed broken in the original, at least I did not
     see that it was used. This version also uses explicit messages to
     have deterministic termination after the traversals is complete.
     It does not do an extra traversal for termination, since we already
     got the upward traversal after #traverse *)
  public class UnbalancedCobwebbedTree nodes: maxNodes binomial: numChildren avgCompSize: avg stdevCompSize: stdev = Benchmark <: Value (
  | private numChildren   = numChildren.
    private avgCompSize   = avg.
    private stdevCompSize = stdev.
    private maxNodes      = maxNodes.
  |)(
    class RootActor new: completionRes = (
    | private ran = Random new.
      private height ::= 1.
      private size   ::= 1.
      private children = Array new: numChildren.
      private hasGrantChildren = Array new: numChildren withAll: false.
      private traversedChildren ::= 0.
      private subtreeSize       ::= 0.
      private startedTraversal ::= false.
      private completionRes = completionRes.
    |)(
      public generateTree = (
        | computationSize i j |
        height := height + 1.
        computationSize := getNextNormal: avgCompSize with: stdevCompSize.

        1 to: numChildren do: [:i |
          | nodeActor |
          nodeActor := (actors createActorFromValue: NodeActor)
             <-: parent: self root: self height: height id: size + 1 computation: computationSize.
          children at: i put: nodeActor.
        ].
        
        size := size + numChildren.
        
        children do: [:c | c <-: tryGeneratedChildren ]
      )
      
      public shouldGenerateChildren: child height: childHeight = (
        size + numChildren <= maxNodes
          ifTrue: [
            | moreChildren |
            moreChildren := ran nextBoolean.
            moreChildren ifTrue: [
              | childComp randomInt |
              childComp := getNextNormal: avgCompSize with: stdevCompSize.
              child <-: generateChildren: size computation: childComp.
              size := size + numChildren.
              
              childHeight + 1 > height ifTrue: [ height := childHeight + 1 ].
            ] ifFalse: [
              childHeight > height ifTrue: [ height := childHeight ] ] ]
          ifFalse: [
            startedTraversal ifFalse: [
              startedTraversal := true.
              traverse ] ]
      )
      
      public traversed: treeSize = (
        traversedChildren := traversedChildren + 1.
        subtreeSize := subtreeSize + treeSize.

        traversedChildren = numChildren ifTrue: [
          completionRes resolve: subtreeSize.
        ]
      )
      
      public updateGrant: childId = (
        hasGrantChildren at: childId put: true
      )

      private getNextNormal: pMean with: pDev = (
        | result |
        result := 0.
        [ result <= 0 ] whileTrue: [
          | tempDouble |
          tempDouble := ran nextGaussian * pDev + pMean.
          result := tempDouble round
        ].
        ^ result
      )
      
      private traverse = (
        children do: [:c | c <-: traverse ].
      )
    )
    
    class NodeActor parent: parent root: root height: height id: id computation: compSize = (
    | private hasChildren ::= false.
      private traversedChildren ::= 0.
      private subtreeSize ::= 0.
      private children = Array new: numChildren.
      private hasGrantChildren = Array new: numChildren withAll: false.
      private busyLoopRan = Random new.
      
      private myParent   = parent.
      private myRoot     = root.
      private myHeight   = height.
      private myId       = id.
      private myCompSize = compSize.
    |)(
      public tryGeneratedChildren = (
        loop: avgCompSize / 50 with: busyLoopRan.
        myRoot <-: shouldGenerateChildren: self height: myHeight.
      )
      
      public generateChildren: currentId computation: compSize = (
        | myArrayId childrenHeight idValue |
        myArrayId := myId % numChildren.
        myParent <-: updateGrant: myArrayId.
        childrenHeight := myHeight + 1.
        idValue := currentId.
        
        1 to: numChildren do: [:i |
          | node |
          node := (actors createActorFromValue: NodeActor) <-: parent: self root: myRoot height: childrenHeight id: idValue + 1 computation: compSize.
          children at: i put: node.
        ].
        
        hasChildren := true.
        
        children do: [:c | c <-: tryGeneratedChildren ].
      )

      public updateGrant: childId = (
        hasGrantChildren at: childId put: true
      )
      
      public traverse = (
        traversedChildren := 0.
        loop: myCompSize with: busyLoopRan.
        hasChildren
          ifTrue:  [ children do: [:c | c <-: traverse ] ]
          ifFalse: [ myParent <-: traversed: 1 ].
      )
      
      public traversed: treeSize = (
        subtreeSize := subtreeSize + treeSize.
        traversedChildren := traversedChildren + 1.
        traversedChildren = numChildren ifTrue: [
          myParent <-: traversed: subtreeSize + 1.
        ]
      )

      private loop: times with: ran = (
        | result |
        1 to: times do: [:k |
          result := ran next
        ].
        ^ result
      )
    )
    
    public benchmark = (
      | rootActor completionPP |
      completionPP := actors createPromisePair.
      rootActor := (actors createActorFromValue: RootActor) <-: new: completionPP resolver.
      rootActor <-: generateTree.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      ^ result = (maxNodes - numChildren)
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self   nodes: (problem at: 1) asInteger
            binomial: (problem at: 2) asInteger
         avgCompSize: (problem at: 3) asInteger
       stdevCompSize: (problem at: 4) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '200000:10:500:100'
    )
  )

  public class TrapezoidalApproximation numWorkers: w numPieces: n left: l right: r = Benchmark <: Value (
  | private numWorkers = w.
    private numPieces  = n.
    private left       = l.
    private right      = r.
    private precision  = (r - l) // n.
  |)(
    class Master new: completionRes = (
    | private workers = Array new: numWorkers withAll: ((actors createActorFromValue: Worker) <-: new: self).
      private completionRes    = completionRes.
      private numTermsReceived ::= 0.
      private resultArea       ::= 0.0.
    |)(
      public result: result = (
        numTermsReceived := numTermsReceived + 1.
        resultArea := resultArea + result.
        
        numTermsReceived = numWorkers ifTrue: [
          completionRes resolve: resultArea ]
      )
      
      public work: l and: r and: h = (
        | workerRange |
        workerRange := (r - l) // numWorkers.
        workers doIndexes: [:i |
          | wl wr |
          wl := workerRange * (i - 1) + l.
          wr := wl + workerRange.
          (workers at: i) <-: work: l and: r and: h
        ]
      )
    )
    
    class Worker new: master = (
    | private master = master.
    |)(
      public work: l and: r and: h = (
        | n accumArea |
        n := (r - l) / h.
        accumArea := 0.0.
        
        0 to: n - 1 do: [:i |
          | lx rx ly ry area |
          lx := (i * h) + l.
          rx := lx + h.
          
          ly := fx: lx.
          ry := fx: rx.
          
          area := 0.5 * (ly + ry) * h.
          accumArea := accumArea + area.
        ].
        
        master <-: result: accumArea
      )
      
      private fx: x = (
        | a b c d r |
        a := ((x * x * x) - 1.0) sin.
        b := x + 1.0.
        c := a // b.
        d := ((2.0 * x) exp + 1.0) sqrt.
        r := c * d.
        ^ r
      )
    )
    
    public benchmark = (
      | master completionPP |
      completionPP := actors createPromisePair.
      master := (actors createActorFromValue: Master) <-: new: completionPP resolver.
      master <-: work: left and: right and: precision.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      (numWorkers = 100 and: [numPieces =  2500 and: [left = 1 and: [right = 5]]]) ifTrue: [ ^ result = 41.09037687472329 ].
      (numWorkers = 100 and: [numPieces =  5000 and: [left = 1 and: [right = 5]]]) ifTrue: [ ^ result = 41.09352993029936 ].
      (numWorkers = 100 and: [numPieces = 10000 and: [left = 1 and: [right = 5]]]) ifTrue: [ ^ result = 41.0943179572127  ].
    
      (* otherwise, warn that we don't know whether it is correct. *)
      ('---- result: ' + result asString + ' dont have a hardcoded verification result for this config yet') println.
      ^ false
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self numWorkers: (problem at: 1) asInteger
              numPieces: (problem at: 2) asInteger
                   left: (problem at: 3) asInteger
                  right: (problem at: 4) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '100:10000000:1:5'
    )
  )
  
  
  public class SuccessiveOverRelaxation = Benchmark ()( todo = ( USES_SHARED_ARRAYS ) )

  (* This benchmark uses originally shared grid nodes.
     The interesting property is that the updates are conceptually safe even
     when they are racy. The benchmark just tries to establish the parent
     relationship. However, we actually need the information about whether we
     succeeded with the update to determine which actor should continue
     processing the updated node.
  
     For this version, we will use Grid actors that actually hold the grid nodes
     to avoid sequentializing the access during the search phase.
  
     Note further, that the #search:target: method is much more complex since
     it is needs to be fully asynchronous.
     The #initializeData method is also more complex. I unrolled the loop to
     avoid the complexity of having to handle the asynchronicity there as well.
  
     Another critical difference is that we do not calculate the distance from
     root, because it is not used. And pretty annoying to implement properly
     synchronized. Which it isn't in the original code either.
     Also, FarRefs are not polymorphic with local refs, which makes this very
     strange.
   *)
  public class AStarSearch numWorkers: numWorkers gridSize: gridSize = Benchmark <: Value (
  | private numWorkers = numWorkers.
    private gridSize   = gridSize.
    private threshold  = 1024. |
  )(
    class GridNode id: id i: i j: j k: k = (
    | public id = id.
      public i  = i.
      public j  = j.
      public k  = k.
      private neighbors = Vector new.
      public parentInPath ::= nil.
      public distanceFromRoot ::= 0.
    | 
      clearParentAndDistance.
    )(
      public clearParentAndDistance = (
        parentInPath     := nil.
        distanceFromRoot := id = 1 ifTrue: [0] ifFalse: [-1].
      )

      private addNeighbor: node = (
        node == self ifTrue: [ ^ false ].
        neighbors do: [:n | n == node ifTrue: [ ^ false ] ].

        neighbors append: node.
        ^ true
      )
      
      public addNeighborsA: a b: b c: c d: d e: e f: f addA: addA addB: addB addC: addC addD: addD addE: addE addF: addF = (
        | addedNeighbor |
        addedNeighbor := false.
  
        addA ifTrue: [ (addNeighbor: a) ifTrue: [ addedNeighbor := true ] ].
        addB ifTrue: [ (addNeighbor: b) ifTrue: [ addedNeighbor := true ] ].
        addC ifTrue: [ (addNeighbor: c) ifTrue: [ addedNeighbor := true ] ].
        addD ifTrue: [ (addNeighbor: d) ifTrue: [ addedNeighbor := true ] ].
        addE ifTrue: [ (addNeighbor: e) ifTrue: [ addedNeighbor := true ] ].
        (addedNeighbor not or: [addF])
          ifTrue: [ addNeighbor: f ].
      )
      
      public numNeighbors = (
        ^ neighbors size
      )
      
      public neighbor: id = (
        ^ neighbors at: id
      )
      
      public setParent: node = (
        parentInPath == nil ifFalse: [ ^ false ].
        
        parentInPath := node.
        
        (* node could be a far reference here, not sure how to get this right:
           distanceFromRoot := node distanceFromRoot + (distanceFrom: node). *)
        ^ true
      )
      
      private distanceFrom: node = (
        (* Not implemented!
         | iDiff jDiff kDiff |
        iDiff := i - node i.
        jDiff := j - node j.
        kDiff := k - node k.
        ^ ((iDiff * iDiff) + (jDiff * jDiff) + (kDiff * kDiff)) sqrt round *)
        ^ self
      )
    )
  
    class Master new: completionRes = (
    | private workers = Array new: numWorkers withAll: [(actors createActorFromValue: Worker) <-: new: self].
      private numWorkersTerminated ::= 0.
      private numWorkSent          ::= 0.
      private numWorkCompleted     ::= 0.
      private allNodes = Array new: gridSize * gridSize * gridSize.
      private completionRes = completionRes.
    |
      initializeData whenResolved: [:r | sendWork: originNode target: targetNode ]
    )(
      private originNode = (
        ^ allNodes at: 1
      )
      
      private targetNode = (
        | axisVal targetId |
        axisVal := (0.8 * gridSize) round.
        targetId := (axisVal * gridSize * gridSize) + (axisVal * gridSize) + axisVal + 1.
        ^ allNodes at: targetId
      )
      
      private sendWork: origin target: target = (
        | workerIdx |
        workerIdx := numWorkSent % numWorkers + 1.
        numWorkSent := numWorkSent + 1.
        (workers at: workerIdx) <-: work: origin target: target.
      )
      
      private createGridNodes: gridActors = (
        | id gs1 |
        gs1 := gridSize - 1. (* for offset-based numbers *)
        id := 1.
        ^ actors async: 0 to: gs1 do: [:i |
          | gridActor |
          gridActor := gridActors at: (i / 3) + 1.
          
          actors async: 0 to: gs1 do: [:j |
            actors async: 0 to: gs1 do: [:k |
              (gridActor <-: id: id i: i j: j k: k) whenResolved: [:gridNode |
                allNodes at: id put: gridNode.
                id := id + 1 ] ] ] ].
      )
      
      private setNeighbors = (
        | random id gs1 g2 |
        gs1 := gridSize - 1. (* for offset-based numbers *)
        g2 := gridSize * gridSize.
        
        random := Random new.
        id := 1.
        
        (* We unrolled this loop to avoid having to rewrite it with #whenResolved callbacks.
           This is certainly not nice code, and not idiomatic either...
        
        | iterCount neighborCount |
        iterCount     := 0.
        neighborCount := 0.
        
         0 to: 1 do: [:i |
          0 to: 1 do: [:j |
            0 to: 1 do: [:k |
              iterCount := iterCount + 1.
              iterCount = 1 or: [iterCount = 8] ifFalse: [
                | addNeighbor |
                addNeighbor := (iterCount = 7 and: [neighborCount = 0]) or: [random nextBoolean].
                addNeighbor ifTrue: [
                  | newI newJ newK newId newNode |
                  newI := (gridSize - 1) min: (gridNode i + i).
                  newJ := (gridSize - 1) min: (gridNode j + j).
                  newK := (gridSize - 1) min: (gridNode k + k).
                  newId := (gridSize * gridSize * newI) + (gridSize * newJ) + newK + 1.
                  newNode := allNodes at: newId.
                
                  (gridNode addNeighbor: newNode)
                    ifTrue: [ neighborCount := neighborCount + 1 ] ] ] ] ] ] ]. *)
        
        0 to: gs1 do: [:i |
          0 to: gs1 do: [:j |
            0 to: gs1 do: [:k |
              (allNodes at: id) <-: addNeighborsA: (allNodes at: (g2 * (gs1 min: i    ))
                                                         + (gridSize * (gs1 min: j    ))
                                                         +             (gs1 min: k + 1) + 1)
                                                b: (allNodes at: (g2 * (gs1 min: i    ))
                                                         + (gridSize * (gs1 min: j + 1))
                                                         +             (gs1 min: k    ) + 1)
                                                c: (allNodes at: (g2 * (gs1 min: i    ))
                                                         + (gridSize * (gs1 min: j + 1))
                                                         +             (gs1 min: k + 1) + 1)
                                                d: (allNodes at: (g2 * (gs1 min: i + 1))
                                                         + (gridSize * (gs1 min: j    ))
                                                         +             (gs1 min: k    ) + 1)
                                                e: (allNodes at: (g2 * (gs1 min: i + 1))
                                                         + (gridSize * (gs1 min: j    ))
                                                         +             (gs1 min: k + 1) + 1)
                                                f: (allNodes at: (g2 * (gs1 min: i + 1))
                                                         + (gridSize * (gs1 min: j + 1))
                                                         +             (gs1 min: k    ) + 1)
                                                addA: random nextBoolean
                                                addB: random nextBoolean
                                                addC: random nextBoolean
                                                addD: random nextBoolean
                                                addE: random nextBoolean
                                                addF: random nextBoolean.
              id := id + 1 ] ] ]
      )

      private initializeData = (
        | gridActors |
        gridActors := Array new: (gridSize / 3) + 1 withAll: [actors createActorFromValue: GridNode].
        
        ^ (createGridNodes: gridActors) whenResolved: [:r |
          setNeighbors.
          allNodes do: [:gridNode |
            (* This does not need synchronization, because we rely on the fact
               that message order is guaranteed from the same sending actor,
               and that the addNeighbors* message doesn't do any message sending
               either. *)
            gridNode <-: clearParentAndDistance ] ]
      )
      
      public work: origin target: target = (
        sendWork: origin target: target
      )
      
      public received = (
        numWorkCompleted := numWorkCompleted + 1.
        numWorkCompleted = numWorkSent ifTrue: [
          requestWorkersToStop ]
      )
      
      public done = (
        requestWorkersToStop
      )
      
      public stop = (
        numWorkersTerminated := numWorkersTerminated + 1.
        numWorkersTerminated = numWorkers ifTrue: [
          completionRes resolve: validate
        ]
      )
      
      private validate = (
        | parentNode nextProm next loop |
        loop := actors createPromisePair.
        parentNode := targetNode.
        
        nextProm := parentNode <-: parentInPath.
        nextProm whenResolved: [:next |
          | n |
          n := next.
          loop resolve: (actors async: [(n == nil) not] whileTrue: [
            parentNode := n.
            (parentNode <-: parentInPath) whenResolved: [:nn | n := nn] ]) ].
        
        ^ loop promise whenResolved: [:r | parentNode == originNode]
      )
      
      private requestWorkersToStop = (
        workers do: [:w | w <-: stop ]
      )
    )

    class Worker new: master = (
    | private master = master.
      private random = Random new. |
    )(
      private busyLoop = (
        1 to: 100 do: [:i | random next ]
      )
    
      public work: origin target: target = (
        (search: origin target: target)
          whenResolved: [:r | master <-: received ]
      )

      public stop = (
        master <-: stop
      )
      
      private search: origin target: target = (
        | workQueue nodesProcessed continue outerLoopProm |
        workQueue := Vector new.
        workQueue append: origin.
        continue := true.
        
        nodesProcessed := 0.
        
        outerLoopProm := actors async: [
          workQueue isEmpty not and: [nodesProcessed < threshold and: continue]] whileTrue: [
          | loopNode numNeighbors outerIterationDone |
          outerIterationDone := actors createPromisePair.
          nodesProcessed := nodesProcessed + 1.
          busyLoop.
          
          loopNode := workQueue removeFirst.
          (loopNode <-: numNeighbors) whenResolved: [:numNeighbors |
            | i whileCompletionPromise |
            i := 1.

            whileCompletionPromise := actors async: [i <= numNeighbors and: continue] whileTrue: [
              | iterationDone |
              iterationDone := actors createPromisePair.
              
              (loopNode <-: neighbor: i) whenResolved: [:loopNeighbor |
                (loopNeighbor <-: setParent: loopNode)
                  whenResolved: [:success |
                    success ifTrue: [
                      loopNeighbor == target ifTrue: [
                        master <-: done.
                        continue := false
                      ] ifFalse: [
                        workQueue append: loopNeighbor ] ].
                    i := i + 1.
                    iterationDone resolve: nil ] ].
              iterationDone promise ].
            outerIterationDone resolve: whileCompletionPromise ].
          outerIterationDone promise ].
        
        ^ outerLoopProm whenResolved: [:r |
          [workQueue isEmpty] whileFalse: [
            master <-: work: workQueue removeFirst target: target ] ]
      )
    )
  
    public benchmark = (
      | completionPP |
      completionPP := actors createPromisePair.
      (actors createActorFromValue: Master) <-: new: completionPP resolver.
      ^ completionPP promise
    )
    
    public verifyResult: aBool = (
      ^ aBool
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self numWorkers: (problem at: 1) asInteger
               gridSize: (problem at: 2) asInteger
    )
    
    public setupVerifiedRun: run = (
      self todo.
      run problemSize: '100:100'
    )
  )

  public class NQueens = Benchmark ()( todo = ( USES_SHARED_STATE ) )
)
