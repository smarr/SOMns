class Savina usingPlatform: platform andHarness: harness = (
| private Benchmark = harness Benchmark.
  private actors    = platform actors.
  private Array     = platform kernel Array.
  private Dictionary= platform collections Dictionary.
  private system    = platform system.
|
)(
  (* A simple PRNG, to be as portable as possible. *)
  public class Random new: seed = (
    | private seed ::= seed. |
  ) (
    public next = (
      seed := ((seed * 1309) + 13849) & 65535.
      ^ seed
    )
  ) : (
    public new = (
      ^ new: 74755
    )
  )

  (* === Savina Microbenchmarks === *)
  
  public class PingPong new: numPings = Benchmark (
  | private completionPP = actors createPromisePair.
    private NumPings     = numPings.
  |
  )(
    class Ping new: cnt with: pong = (
      | private pingsLeft ::= cnt.
        private pong = pong.
      |
    ) (
      public start = (
        pong <-: ping: self.
        pingsLeft := pingsLeft - 1.
      )
    
      public ping = (
        pong <-: ping: self.
        pingsLeft := pingsLeft - 1.
      )
    
      public pong: sender = (
        pingsLeft > 0
          ifTrue:  [ self <-: ping ]
          ifFalse: [ pong <-: stop ].
      )
    )
  
    class Pong = (
      | private pongCount ::= 0. |
    ) (
      public ping: sender = (
        sender <-: pong: self.
        pongCount := pongCount + 1.
      )
    
      public stop = (
        completionPP resolve: pongCount
      )
    )
    
    public benchmark = (
      | ping pong |
      pong := (actors createActorFromValue: Pong) <-: new.
      ping := (actors createActorFromValue: Ping) <-: new: NumPings with: pong.
      ping <-: start.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      ^ result = NumPings
    )
  ) : (
    public newInstance: problemSize = ( ^ self new: problemSize asInteger )
    public setupVerifiedRun: run = ( run problemSize: 1 )
  )

  public class Counting new: limit = Benchmark (
  | private limit = limit.
    private completionPP = actors createPromisePair. |
  )(
    public class ProducerActor new: counter = (
    | private counter = counter.
      (* TODO: need to add a mutable field to ProducerActor to get a far reference, otherwise it is a Value.
         TODO: we should probably not make all possible Values Values. Need to think about that.
               perhaps we need to require explicit mixing in Value (and have a check that it is legal) *)
      private mutableFieldHackToGetThisObjectAsFarReference ::= 0.
    |
    )(
      public increment = (
        1 to: limit do: [:i |
          counter <-: increment ].
        
        counter <-: requestCount: self.
      )
      
      public count: cnt = (
        completionPP resolve: cnt = limit
      )
    )
    
    public class CountingActor = (
    | private count ::= 0. |
    ) (
      public increment = (
        count := count + 1.
      )
      
      public requestCount: requester = (
        requester <-: count: count
      )
    )
  
    public benchmark = (
      | counter producer |
      counter  := (actors createActorFromValue: CountingActor) <-: new.
      producer := (actors createActorFromValue: ProducerActor) <-: new: counter.
      producer <-: increment.

      ^ completionPP promise
    )
    
    public verifyResult: isCorrect = (
      ^ isCorrect
    )
  ) : (
    public newInstance: problemSize = ( ^ self new: problemSize asInteger )
    public setupVerifiedRun: run = ( run problemSize: 10000 )
  )

  public class ForkJoinThroughput new: numActors  totalMessages: numMessages = Benchmark (
  | private numActors    = numActors.
    private numMessages  = numMessages.
  |
  )(
    class ThroughputActor new: completionResolver = (
    | private messagesProcessed  ::= 0.
      private completionResolver = completionResolver.
    |
    )(
      private performComputation: theta = (
        | sint res |
        sint := theta sin.
        res := sint * sint.
        
        (* defeat dead code elimination *)
        res <= 0.0 ifTrue: [
          system error: 'Benchmark calculated unrealistic res value ' + res asString ]
      )
     
      public process = (
        messagesProcessed := messagesProcessed + 1.
        self performComputation: 37.2.
        
        messagesProcessed = numMessages ifTrue: [
          completionResolver resolve: messagesProcessed
        ]
      )
    )
  
    public benchmark = (
      | benchActors promiseGroup |
      promiseGroup := nil.
      benchActors := Array new: numActors withAll: [
        | promisePair |
        promisePair := actors createPromisePair.
        promiseGroup
          ifNil:    [ promiseGroup := promisePair promise ]
          ifNotNil: [ promiseGroup := promiseGroup, promisePair promise ].
        (actors createActorFromValue: ThroughputActor) <-: new: promisePair resolver
      ].
      
      numMessages timesRepeat: [
        benchActors do: [:a | a <-: process ] ].
      
      ^ promiseGroup
    )
    
    public verifyResult: result = (
      result do: [:n | n = numMessages ifFalse: [ ^ false ] ].
      ^ true
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self new: (problem at: 1) asInteger
         totalMessages: (problem at: 2) asInteger
    )
    public setupVerifiedRun: run = ( run problemSize: '100:1000' )
  )

  public class ForkJoinActorCreation new: numActors = Benchmark (
  | private numActors = numActors. |
  )(
    class ForkJoinActor new: completionResolver = (
    | (* TODO: should not need to this field. need it currently to get a far reference. remove it once we fixed that. *)
      private mutableFieldHackToGetThisObjectAsFarReference ::= 0.  
    |
      completionResolver resolve: (performComputation: 37.2)
    )()
    
    private performComputation: theta = (
      | sint res |
      sint := theta sin.
      res := sint * sint.

      res <= 0.0 ifTrue: [
        system error: 'Benchmark calculated unrealistic res value ' + res asString ].
      ^ res
    )
  
    public benchmark = (
      | promiseGroup |
      promiseGroup := nil.
      
      numActors timesRepeat: [
        | promisePair |
        promisePair := actors createPromisePair.
        promiseGroup
          ifNil:    [ promiseGroup := promisePair promise ]
          ifNotNil: [ promiseGroup := promiseGroup, promisePair promise ].
        (actors createActorFromValue: ForkJoinActor) <-: new: promisePair resolver.
      ].
      ^ promiseGroup
    )
    
    public verifyResult: resultVector = (
      | expResult |
      expResult := performComputation: 37.2.
      resultVector do: [:r | r = expResult ifFalse: [ ^ false ] ].
      ^ true
    )
  ) : (
    public newInstance: problemSize = ( ^ self new: problemSize asInteger )
    public setupVerifiedRun: run = ( run problemSize: 1 )
  )
  
  public class ThreadRing new: numThreads = Benchmark (
  | private N = numThreads.
    private completionPP = actors createPromisePair.
  |
  )(
    class ThreadRingActor new: id numActorsInRing: num = (
    | private id = id.
      private numActorsInRing = num.
      private nextAct ::= nil.
    |
    )(
      public ping: t = (
        t > 0 ifTrue: [
          nextAct <-: ping: t - 1
        ] ifFalse: [
          nextAct <-: exit: numActorsInRing
        ]
      )
      
      public exit: t = (
        t > 0 ifTrue: [
          nextAct <-: exit: t - 1
        ] ifFalse: [
          completionPP resolve: id.
        ]
      )
      
      public nextActor: actor = (
        nextAct := actor
      )
    )
    
    public benchmark = (
      | threadActors |
      threadActors := Array new: N.
      1 to: N do: [:i |
        | threadActor |
        threadActor := (actors createActorFromValue: ThreadRingActor)
                         <-: new: i numActorsInRing: N.
        threadActors at: i put: threadActor.
      ].
      
      1 to: N do: [:i |
        | nextActor |
        nextActor := threadActors at: (i % N) + 1.
        (threadActors at: i) <-: nextActor: nextActor.
      ].
      
      (threadActors at: 1) <-: ping: N.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      ^ result = 2
    )
  ) : (
    public newInstance: problemSize = ( ^ self new: problemSize asInteger )
    public setupVerifiedRun: run = ( run problemSize: 1 )
  )
  
  public class Chameneos meetings: numMeetings chameneos: numChameneos = Benchmark (
  | private numMeetings  = numMeetings.
    private numChameneos = numChameneos.
    private completionPP = actors createPromisePair.
    
    private red    = Red    new.
    private yellow = Yellow new.
    private blue   = Blue   new.
    private faded  = Faded  new.
  |
  )(
    class Red = ()(
      public complement: other = ( ^ other redComplement )
      public redComplement     = ( ^ red    )
      public yellowComplement  = ( ^ blue   )
      public blueComplement    = ( ^ yellow )
    )
    class Yellow = ()(
      public complement: other = ( ^ other yellowComplement )
      public redComplement     = ( ^ blue   )
      public yellowComplement  = ( ^ yellow )
      public blueComplement    = ( ^ red    )
    )
    class Blue = ()(
      public complement: other = ( ^ other blueComplement )
      public redComplement     = ( ^ yellow )
      public yellowComplement  = ( ^ red    )
      public blueComplement    = ( ^ blue   )
    )
    class Faded = ()(
      public complement: other = ( ^ faded )
    )
  
    class ChameneosMallActor = (
    | private waitingChameneo ::= nil.
      private sumMeetings     ::= 0.
      private numFaded        ::= 0.
      private n               ::= numMeetings.
    |
      start.
    )(
      private color: anInt = (
        | colorIdx |
        colorIdx := anInt % 3.
        colorIdx = 0 ifTrue: [ ^ red    ].
        colorIdx = 1 ifTrue: [ ^ yellow ].
        colorIdx = 2 ifTrue: [ ^ blue   ].
      )

      private start = (
        0 to: numChameneos - 1 do: [:i |
          | color |
          color := color: i.
          (actors createActorFromValue: ChameneosChameneoActor) <-: new: self color: color
        ]
      )

      public meetingCount: count = (
        numFaded := numFaded + 1.
        sumMeetings := sumMeetings + count.
        numFaded = numChameneos ifTrue: [ completionPP resolve: sumMeetings ]
      )
      
      public meet: sender color: color = (
        n > 0 ifTrue: [
          waitingChameneo
            ifNil: [ waitingChameneo := sender ]
            ifNotNil: [
              n := n - 1.
              waitingChameneo <-: meet: sender color: color.
              waitingChameneo := nil.
            ]
        ] ifFalse: [
          sender <-: exit: self
        ]
      )
    )
    
    class ChameneosChameneoActor new: mall color: color = (
    | private mall       = mall.
      private color    ::= color.
      private meetings ::= 0.
    |
      start.
    )(
      private start = (
        mall <-: meet: self color: color.
      )

      public meet: sender color: otherColor = (
        | complement |
        complement := color complement: otherColor.
        meetings := meetings + 1.
        sender <-: change: color.
        mall   <-: meet: self color: color.
      )
      
      public change: newColor = (
        color := newColor.
        meetings := meetings + 1.
        mall <-: meet: self color: newColor.
      )
      
      public exit: sender = (
        color := faded.
        sender <-: meetingCount: meetings
      )
    )
    
    public benchmark = (
      | mallActor |
      mallActor := (actors createActorFromValue: ChameneosMallActor) <-: new.
      ^ completionPP promise
    )
    
    public verifyResult: sumMeetings = (
      ^ sumMeetings = (2 * numMeetings)
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self meetings: (problem at: 1) asInteger
            chameneos: (problem at: 2) asInteger
    )
    public setupVerifiedRun: run = ( run problemSize: '100:200000' )
  )
  
  public class Big = Benchmark ()( todo = () )
  (* === Savina Concurrency Benchmarks === *)

  public class ConcurrentDictionary numEntities: numEntities numMessages: numMessages writePercentage: writePercentage = Benchmark (
  | private numMessages = numMessages.
    private numEntities = numEntities.
    private writePercentage = writePercentage.
    private completionPP = actors createPromisePair.
  |
  )(
    class Master = (
    | private workers    = Array new: numEntities.
      private dictionary = (actors createActorFromValue: DictionaryActor) <-: new.
      private numWorkersTerminated ::= 0.
    |
      start.
    )(
      private start = (
        workers doIndexes: [:i |
          | worker |
          worker := (actors createActorFromValue: Worker) <-: new: self dict: dictionary id: i.
          workers at: i put: worker.
          worker <-: doWork.
        ]
      )
      
      public endWork = (
        numWorkersTerminated := numWorkersTerminated + 1.
        numWorkersTerminated = numEntities ifTrue: [
          dictionary <-: endWork.
        ]
      )
    )
    
    class Worker new: master dict: dictionary id: id = (
    | private messageCount ::= 0.
      private random = Random new: id + numMessages + writePercentage.
      private master = master.
      private dictionary = dictionary.
    |
    )(
      public doWork = (
        messageCount := messageCount + 1.
        messageCount <= numMessages
          ifTrue: [
            | rnd |
            rnd := random next % 100.
            rnd < writePercentage
              ifTrue:  [ dictionary <-: write: self key: random next value: random next ]
              ifFalse: [ dictionary <-: read: self key: random next ] ]
          ifFalse: [ master <-: endWork ].
      )
      
      public result: value = (
        self doWork
      )
    )
    
    class DictionaryActor = (
    | private dataMap = self createDataMap: 524287 / 1024. (* Integer.MAX_VALUE / 4_096 *)
      private mutableFieldHackToGetThisObjectAsFarReference ::= 0. (* TODO: remove hack *)
    |
    )(
      private createDataMap: dataLimit = (
        | dict |
        dict := Dictionary new.
        1 to: dataLimit do: [:i |
          dict at: i put: i
        ].
        ^ dict
      )
      
      public write: sender key: key value: val = (
        dataMap at: key put: val.
        sender <-: result: val
      )
      
      public read: sender key: key = (
        sender <-: result: (dataMap at: key)
      )
      
      public endWork = (
        completionPP resolve: dataMap size
      )
    )
  
    public benchmark = (
      | master |
      master := (actors createActorFromValue: Master) <-: new.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      ('---- result: ' + result asString) println.
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self numEntities: (problem at: 1) asInteger
             numMessages: (problem at: 2) asInteger
         writePercentage: (problem at: 3) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '100:100:50'
    )
  )
  
  
  public class ConcurrentSortedLinkedList = Benchmark ()( todo = () )
  public class ProducerConsumerBoundedBuffer = Benchmark ()( todo = () )
  public class Philosophers = Benchmark ()( todo = () )
  public class SleepingBarber = Benchmark ()( todo = ( USE_MATH_RANDOM_WHICH_SEQUENTIALIZES ) )
  public class CigaretteSmokers = Benchmark ()( todo = ( USE_MATH_RANDOM_WHICH_SEQUENTIALIZES ) )
  public class LogisticsMapSeries = Benchmark ()( todo = () )
  public class BankTransaction = Benchmark ()( todo = () )
  
  (* === Savina Parallelism Benchmarks === *)
  
  public class RadixSort numValues: numValues maxValue: maxValue seed: seed = Benchmark (
  | private numValues = numValues. 
    private maxValue  = maxValue.  (* Needs to be a power of 2, I think *)
    private seed      = seed.      (* Should probably be a prime number *)
    private completionPP = actors createPromisePair.
  |
  )(
    class IntSourceActor = (
    | private random = Random new: seed. |
    ) (
      public next: actor = (
        1 to: numValues do: [:i |
          | candidate |
          candidate := (random next % maxValue) abs.
          actor <-: value: candidate.
        ]
      )
    )
  
    class SortActor new: radix next: nextActor = (
    | private radix     = radix.
      private next      = nextActor.
      
      private orderingArray = Array new: numValues withAll: 0.
      private valuesSoFar ::= 0.
      private j           ::= 1.
    |
    )(
      public value: current = (
        valuesSoFar := valuesSoFar + 1.
        
        (current & radix) = 0
          ifTrue:  [
           next <-: value: current ]
          ifFalse: [
            orderingArray at: j put: current.
            j := j + 1
          ].
        
        valuesSoFar = numValues ifTrue: [
          1 to: j - 1 do: [:i |
            next <-: value: (orderingArray at: i)
          ].
        ]
      )
    )
    
    class ValidationActor = (
    | private sumSoFar    ::=  0.
      private valuesSoFar ::=  0.
      private prevValue   ::=  0.
      private errorValue  ::= -1.
      private errorIdx    ::= -1.
    |
    )(
      public value: val = (
        valuesSoFar := valuesSoFar + 1.
        
        (val < prevValue and: [errorValue < 0]) ifTrue: [
          errorValue := val.
          errorIdx   := valuesSoFar.
          system error: 'ERROR: Value out of place: ' + errorValue + ' at index ' + errorIdx
        ].
        
        prevValue := val.
        sumSoFar := sumSoFar + prevValue.
        
        valuesSoFar = numValues ifTrue: [
          errorValue >= 0
            ifTrue:  [ system error: 'Value out of place: ' + errorValue + ' at index ' + errorIdx ].
          completionPP resolve: sumSoFar
        ]
      )
    )
  
    public benchmark = (
      | validationActor sourceActor radix nextActor |
      validationActor := (actors createActorFromValue: ValidationActor) <-: new.
      sourceActor     := (actors createActorFromValue: IntSourceActor)  <-: new.
      
      radix := maxValue / 2.
      nextActor := validationActor.
      
      [radix > 0] whileTrue: [
        | sortActor |
        sortActor := (actors createActorFromValue: SortActor) <-: new: radix next: nextActor.
        
        radix := radix / 2.
        nextActor := sortActor
      ].
      
      sourceActor <-: next: nextActor.
      
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      (numValues = 100 and: [maxValue = 256 and: [seed = 74755]]) ifTrue: [
        ^ result = 13606
      ].
      (numValues = 10000 and: [maxValue = 65536 and: [seed = 74755]]) ifTrue: [
        ^ result = 329373752
      ].
      ^ true
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self numValues: (problem at: 1) asInteger
              maxValue: (problem at: 2) asInteger
                  seed: (problem at: 3) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '100:256:74755'
    )
  )
  
  public class FilterBank = Benchmark ()( todo = () )
  
  public class Sieve new: limit local: numMaxLocalPrimes = Benchmark (
  | private limit = limit.
    private numMaxLocalPrimes = numMaxLocalPrimes.
    private completionPP = actors createPromisePair.
  |
  )(
    class NumberProducerActor = ()(
      public produceNumbersFor: filterActor = (
        | candidate |
        candidate := 3.
        [candidate < limit] whileTrue: [
          filterActor <-: filter: candidate.
          candidate := candidate + 2
        ].
        
        filterActor <-: exit.
      )
    )
    
    class PrimeFilterActor new: id initialPrime: initialPrime = (
    | private id = id.
      private initialPrime = initialPrime.
      private nextFilterActor ::= nil.
      private localPrimes = Array new: numMaxLocalPrimes withAll: 0.
      private availableLocalPrimes ::= 1.
    |
      localPrimes at: 1 put: initialPrime.
    )(
      private handleNewPrim: newPrim = (
        availableLocalPrimes < numMaxLocalPrimes
          ifTrue: [
            (* store locally if there is space *)
            availableLocalPrimes := availableLocalPrimes + 1.
            localPrimes at: availableLocalPrimes put: newPrim ]
          ifFalse: [
            (* create a new actor to store a new prime *)
            nextFilterActor := (actors createActorFromValue: PrimeFilterActor)
              <-: new: id + 1 initialPrime: newPrim
          ]
      )
      
      private isLocallyPrime: candidate = (
        1 to: availableLocalPrimes do: [:i |
          | remainder |
          remainder := candidate % (localPrimes at: i).
          remainder = 0 ifTrue: [ ^ false ]
        ].
        ^ true
      )
      
      public filter: candidate = (
        (isLocallyPrime: candidate)
          ifTrue: [
            nextFilterActor
              ifNil:    [handleNewPrim: candidate]
              ifNotNil: [nextFilterActor <-: filter: candidate]
          ]
      )
      public exit = (
        nextFilterActor
          ifNil: [
            | totalPrimes |
            totalPrimes := ((id - 1) * numMaxLocalPrimes) + availableLocalPrimes.
            completionPP resolve: totalPrimes ]
          ifNotNil: [ nextFilterActor <-: exit ]
      )
    )
   
    public benchmark = (
      | producerActor filterActor |
      producerActor := (actors createActorFromValue: NumberProducerActor) <-: new.
      filterActor   := (actors createActorFromValue: PrimeFilterActor)    <-: new: 1 initialPrime: 2.

      producerActor <-: produceNumbersFor: filterActor.
      
      ^ completionPP promise
    )
    
    public verifyResult: numberOfPrimes = (
      limit = 100    ifTrue: [ ^ numberOfPrimes =   25 ].
      limit = 1000   ifTrue: [ ^ numberOfPrimes =  168 ].
      limit = 10000  ifTrue: [ ^ numberOfPrimes = 1229 ].
      limit = 100000 ifTrue: [ ^ numberOfPrimes = 9592 ].
      (* otherwise, we don't know. *)
      ^ true 
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self new: (problem at: 1) asInteger
           local: (problem at: 2) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '100000:64'
    )
  )
  
  public class UnbalancedBobwebbedTree = Benchmark ()( todo = () )
  public class OnlineFacilityLocation = Benchmark ()( todo = () )
  public class TrapezoidalApproximation = Benchmark ()( todo = () )
  public class PrecisePiComputation = Benchmark ()( todo = () )
  public class RecursiveMatricMultiplication = Benchmark ()( todo = () )
  public class Quicksort = Benchmark ()( todo = () )
  public class AllPairsShortestPath = Benchmark ()( todo = ( USES_SHARED_STATE ) )
  
  
  public class SuccessiveOverRelaxation = Benchmark ()( todo = () )
  public class AStarSearch = Benchmark ()( todo = ( USES_A_GLOBAL_RANDOM_INSTANCE ) )
  public class NQueens = Benchmark ()( todo = ( USES_SHARED_STATE ) )
)
