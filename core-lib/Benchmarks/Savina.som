class Savina usingPlatform: platform andHarness: harness = Value (
| private Benchmark = harness Benchmark.
  private actors    = platform actors.
  private Array     = platform kernel Array.
  private TransferArray= platform kernel TransferArray.
  private Vector    = platform kernel Vector.
  private Dictionary= platform collections Dictionary.
  private system    = platform system.
|
)(
  (* A simple PRNG, to be as portable as possible. *)
  public class Random new: seed = (
    | private seed ::= seed.
      private gotNextGaussian  ::= false.
      private nextNextGaussian ::= 0.0. |
  ) (
    public next = (
      seed := ((seed * 1309) + 13849) & 65535.
      ^ seed
    )
    
    (* Returns an integer within the range of [0, bound) *)
    public next: bound = (
      ^ next % bound
    )
    
    (* Returns a double uniformly distributed in the range of [0.0, 1.0) *)
    public nextDouble = (
      ^ next // 65536
    )
    
    public nextBoolean = (
      ^ next < 32768
    )
    
    (* Returns a double normally distributed with mean 0.0 
       and standard deviation of 1.0 *)
    public nextGaussian = (
      | v1 v2 s multiplier |
      gotNextGaussian ifTrue: [
        gotNextGaussian := false.
        ^ nextNextGaussian ].
      
      v1 := (2.0 * nextDouble) - 1.0.
      v2 := (2.0 * nextDouble) - 1.0.
      s  := (v1 * v1) + (v2 * v2).
      
      [s >= 1.0 or: [s = 0.0]] whileTrue: [
        v1 := (2.0 * nextDouble) - 1.0.
        v2 := (2.0 * nextDouble) - 1.0.
        s  := (v1 * v1) + (v2 * v2).
      ].
      
      multiplier := (-2.0 * s log // s) sqrt.
      nextNextGaussian := v2 * multiplier.
      gotNextGaussian := true.
      ^ v1 * multiplier
    )
  ) : (
    public new = (
      ^ new: 74755
    )
  )

  (* === Savina Microbenchmarks === *)
  
  public class PingPong new: numPings = Benchmark <: Value (
  | private NumPings = numPings.
  |
  )(
    class Ping new: cnt with: pong = (
      | private pingsLeft ::= cnt.
        private pong = pong.
      |
    ) (
      public start = (
        pong <-: ping: self.
        pingsLeft := pingsLeft - 1.
      )
    
      public ping = (
        pong <-: ping: self.
        pingsLeft := pingsLeft - 1.
      )
    
      public pong: sender = (
        pingsLeft > 0
          ifTrue:  [ self <-: ping ]
          ifFalse: [ pong <-: stop ].
      )
    )
  
    class Pong new: completionRes = (
    | private pongCount ::= 0.
      private completionRes = completionRes.
    |
    ) (
      public ping: sender = (
        sender <-: pong: self.
        pongCount := pongCount + 1.
      )
    
      public stop = (
        completionRes resolve: pongCount
      )
    )
    
    public benchmark = (
      | ping ping2 pong completionPP |
      completionPP := actors createPromisePair.
      pong := (actors createActorFromValue: Pong) <-: new: completionPP resolver.
      ping := (actors createActorFromValue: Ping) <-: new: NumPings with: pong.
      ping2 := (actors createActorFromValue: Ping) <-: new: NumPings with: pong.
      ping <-: start.
      ping2 <-: start.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      ^ result = NumPings
    )
  ) : (
    public newInstance: problemSize = ( ^ self new: problemSize asInteger )
    public setupVerifiedRun: run = ( run problemSize: 1 )
  )
  (* === Counting === *)
  public class Counting new: limit = Benchmark <: Value (
  | private limit = limit. |
  )(
    public class ProducerActor new: counter resolver: completionRes = (
    | private counter = counter.
      private completionRes = completionRes.
    |
    )(
      public increment = (
        1 to: limit do: [:i |
          counter <-: increment ].
        
        counter <-: requestCount: self.
      )
      
      public count: cnt = (
        completionRes resolve: cnt = limit
      )
    )
    
    public class CountingActor = (
    | private count ::= 0. |
    ) (
      public increment = (
        count := count + 1.
      )
      
      public requestCount: requester = (
        requester <-: count: count
      )
    )

    public class DisturbanceActor new: counter = (
    | private counter = counter.
      private turns ::= limit / 3.
    |
    )(
      public disturb = (
        (turns = 0) ifTrue: [counter <-: increment.]
                    ifFalse: [
                      turns := turns -1.
                      self <-: disturb]
      )
    )
  
    public benchmark = (
      | counter producer disturb completionPP |
      completionPP := actors createPromisePair.
      counter  := (actors createActorFromValue: CountingActor) <-: new.
      producer := (actors createActorFromValue: ProducerActor) <-: new: counter resolver: completionPP resolver.
      disturb := (actors createActorFromValue: DisturbanceActor) <-: new: counter.
      producer <-: increment.
      disturb <-: disturb.

      ^ completionPP promise
    )
    
    public verifyResult: isCorrect = (
      ^ isCorrect
    )
  ) : (
    public newInstance: problemSize = ( ^ self new: problemSize asInteger )
    public setupVerifiedRun: run = ( run problemSize: 10000 )
  )

  (* === ForkJoinThroughput === *)
  public class ForkJoinThroughput new: numActors  totalMessages: numMessages = Benchmark <: Value (
  | private numActors    = numActors.
    private numMessages  = numMessages.
  |
  )(
    class ThroughputActor new: completionResolver = (
    | private messagesProcessed  ::= 0.
      private completionResolver = completionResolver.
    |
    )(
      private performComputation: theta = (
        | sint res |
        sint := theta sin.
        res := sint * sint.
        
        (* defeat dead code elimination *)
        res <= 0.0 ifTrue: [
          system error: 'Benchmark calculated unrealistic res value ' + res asString ]
      )
     
      public process = (
        messagesProcessed := messagesProcessed + 1.
        self performComputation: 37.2.
        
        messagesProcessed = numMessages ifTrue: [
          completionResolver resolve: messagesProcessed
        ]
      )
    )
  
    public benchmark = (
      | benchActors promiseGroup |
      promiseGroup := nil.
      benchActors := Array new: numActors withAll: [
        | promisePair |
        promisePair := actors createPromisePair.
        promiseGroup
          ifNil:    [ promiseGroup := promisePair promise ]
          ifNotNil: [ promiseGroup := promiseGroup, promisePair promise ].
        (actors createActorFromValue: ThroughputActor) <-: new: promisePair resolver
      ].
      
      numMessages timesRepeat: [
        benchActors do: [:a | a <-: process ] ].
      
      ^ promiseGroup
    )
    
    public verifyResult: result = (
      result do: [:n | n = numMessages ifFalse: [ ^ false ] ].
      ^ true
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self new: (problem at: 1) asInteger
         totalMessages: (problem at: 2) asInteger
    )
    public setupVerifiedRun: run = ( run problemSize: '100:1000' )
  )

  (* === ForkJoinActorCreation === *)
  public class ForkJoinActorCreation new: numActors = Benchmark <: Value (
  | private numActors = numActors. |
  )(
    class ForkJoinActor new: completionResolver = (
      completionResolver resolve: (performComputation: 37.2)
    )()
    
    private performComputation: theta = (
      | sint res |
      sint := theta sin.
      res := sint * sint.

      res <= 0.0 ifTrue: [
        system error: 'Benchmark calculated unrealistic res value ' + res asString ].
      ^ res
    )
  
    public benchmark = (
      | promiseGroup |
      promiseGroup := nil.
      
      numActors timesRepeat: [
        | promisePair |
        promisePair := actors createPromisePair.
        promiseGroup
          ifNil:    [ promiseGroup := promisePair promise ]
          ifNotNil: [ promiseGroup := promiseGroup, promisePair promise ].
        (actors createActorFromValue: ForkJoinActor) <-: new: promisePair resolver.
      ].
      ^ promiseGroup
    )
    
    public verifyResult: resultVector = (
      | expResult |
      expResult := performComputation: 37.2.
      resultVector do: [:r | r = expResult ifFalse: [ ^ false ] ].
      ^ true
    )
  ) : (
    public newInstance: problemSize = ( ^ self new: problemSize asInteger )
    public setupVerifiedRun: run = ( run problemSize: 1 )
  )
  
  (* === ThreadRing ===*)
  public class ThreadRing new: numActors numPings: numPings = Benchmark <: Value(
  | private numActors = numActors.
    private numPings  = numPings.
  |
  )(
    class ThreadRingActor new: id resolver: completionRes = (
    | private id = id.
      private nextAct ::= nil.
      private completionRes = completionRes.
    |
    )(
      public ping: t = (
        t > 0 ifTrue: [
          (*runs indefinitely and gobbles up all available RAM with old messages*)
          nextAct <-: ping: t - 0.
        ] ifFalse: [
          nextAct <-: exit: numActors - 1
        ]
      )
      
      public exit: t = (
        t > 0 ifTrue: [
          nextAct <-: exit: t - 1
        ] ifFalse: [
          completionRes resolve: id.
        ]
      )
      
      public nextActor: actor = (
        nextAct := actor
      )
    )
    
    public benchmark = (
      | threadActors completionPP |
      completionPP := actors createPromisePair.
      threadActors := Array new: numActors.
      1 to: numActors do: [:i |
        | threadActor |
        threadActor := (actors createActorFromValue: ThreadRingActor) <-: new: i resolver: completionPP resolver.
        threadActors at: i put: threadActor.
      ].
      
      1 to: numActors do: [:i |
        | nextActor |
        nextActor := threadActors at: (i % numActors) + 1.
        (threadActors at: i) <-: nextActor: nextActor.
      ].

      (threadActors at: 1) <-: ping: numPings.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      ^ result = 1
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self new: (problem at: 1) asInteger
        numPings: (problem at: 2) asInteger
    )
    public setupVerifiedRun: run = ( run problemSize: '30:300' )
  )
  
    (* === Chameneos === *)
  public class Chameneos meetings: numMeetings chameneos: numChameneos = Benchmark <: Value (
  | private numMeetings  = numMeetings.
    private numChameneos = numChameneos.
    
    private red    = Red    new.
    private yellow = Yellow new.
    private blue   = Blue   new.
    private faded  = Faded  new.
  |
  )(
    class Red = Value ()(
      public complement: other = ( ^ other redComplement )
      public redComplement     = ( ^ red    )
      public yellowComplement  = ( ^ blue   )
      public blueComplement    = ( ^ yellow )
    )
    class Yellow = Value ()(
      public complement: other = ( ^ other yellowComplement )
      public redComplement     = ( ^ blue   )
      public yellowComplement  = ( ^ yellow )
      public blueComplement    = ( ^ red    )
    )
    class Blue = Value ()(
      public complement: other = ( ^ other blueComplement )
      public redComplement     = ( ^ yellow )
      public yellowComplement  = ( ^ red    )
      public blueComplement    = ( ^ blue   )
    )
    class Faded = Value ()(
      public complement: other = ( ^ faded )
    )
  
    class ChameneosMallActor new: completionRes = (
    | private waitingChameneo ::= nil.
      private sumMeetings     ::= 0.
      private numFaded        ::= 0.
      private n               ::= numMeetings.
      private completionRes   = completionRes.
    |
      start.
    )(
      private color: anInt = (
        | colorIdx |
        colorIdx := anInt % 3.
        colorIdx = 0 ifTrue: [ ^ red    ].
        colorIdx = 1 ifTrue: [ ^ yellow ].
        colorIdx = 2 ifTrue: [ ^ blue   ].
      )

      private start = (
        0 to: numChameneos - 1 do: [:i |
          | color |
          color := color: i.
          (actors createActorFromValue: ChameneosChameneoActor) <-: new: self color: color
        ]
      )

      public meetingCount: count = (
        numFaded := numFaded + 1.
        sumMeetings := sumMeetings + count.
        numFaded = numChameneos ifTrue: [ completionRes resolve: sumMeetings ]
      )
      
      public meet: sender color: color = (
        n > 0 ifTrue: [
          waitingChameneo
            ifNil: [ waitingChameneo := sender ]
            ifNotNil: [
              n := n - 1.
              waitingChameneo <-: meet: sender color: color.
              waitingChameneo := nil.
            ]
        ] ifFalse: [
          sender <-: exit: self
        ]
      )
    )
    
    class ChameneosChameneoActor new: mall color: color = (
    | private mall       = mall.
      private color    ::= color.
      private meetings ::= 0.
    |
      start.
    )(
      private start = (
        mall <-: meet: self color: color.
      )

      public meet: sender color: otherColor = (
        | complement |
        complement := color complement: otherColor.
        meetings := meetings + 1.
        sender <-: change: color.
        (*mall   <-: meet: self color: color.*)
      )
      
      public change: newColor = (
        color := newColor.
        meetings := meetings + 1.
        mall <-: meet: self color: newColor.
      )
      
      public exit: sender = (
        color := faded.
        sender <-: meetingCount: meetings
      )
    )
    
    public benchmark = (
      | mallActor completionPP |
      completionPP := actors createPromisePair.
      mallActor := (actors createActorFromValue: ChameneosMallActor) <-: new: completionPP resolver.
      ^ completionPP promise
    )
    
    public verifyResult: sumMeetings = (
      ^ sumMeetings = (2 * numMeetings)
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self meetings: (problem at: 1) asInteger
            chameneos: (problem at: 2) asInteger
    )
    public setupVerifiedRun: run = ( run problemSize: '100:200000' )
  )

  (* Does not send the unnecessary exit messages because of using the promise
     for completion. *)

  public class BigContention numWorkers: numWorkers numMessages: numMessages = Benchmark <: Value (
  | private numMessages = numMessages.
    private numWorkers  = numWorkers.
  |
  )(
    class BigActor new: id sink: sinkActor = (
    | private numPings  ::= 0.
      private expPinger ::= -1.
      public  neighbors ::= nil.
      private random    = Random new: id.
      private id        = id.
      private sinkActor = sinkActor.
    |)(
      public ping: sender = (
        (neighbors at: sender) <-: pong: id.
      )

      public pong: sender = (
        sender = expPinger ifFalse: [
          error: 'ERROR: expected: ' + expPinger asString + ' but received from ' + sender asString ].
        
        numPings = numMessages
          ifTrue:  [ sinkActor <-: exit ]
          ifFalse: [
            sendPing.
            numPings := numPings + 1 ]
      )

      private sendPing = (
        | target |
        target := (random next: neighbors size) + 1.
        expPinger := target.
        (neighbors at: target) <-: ping: id
      )
    )
    
    class SinkActor new: completionRes = (
      | private numMessages ::= 0.
        public  neighbors   ::= nil.
        private completionRes = completionRes.
      |)(
      public exit = (
        numMessages := numMessages + 1.
        numMessages = numWorkers ifTrue: [ completionRes resolve: numMessages ]
      )
    )

    public benchmark = (
      | sinkActor bigActors unwrapPromise completionPP |
      completionPP := actors createPromisePair.
      sinkActor := (actors createActorFromValue: SinkActor) <-: new: completionPP resolver.
      
      bigActors := TransferArray new: numWorkers.
      bigActors doIndexes: [:i |
        bigActors at: i put: ((actors createActorFromValue: BigActor) <-: new: i sink: sinkActor)].
      
      (* we unwrap the promises here to avoid sending chained promises to all
         the actors. If the promise is not yet resolved (a race condition)
         they will end up chained, which is also expensive, especially since
         there need to be send n * m messages instead 2n for the original one
         and the callback *)
      unwrapPromise := actors async: 1 to: numWorkers do: [:i |
        (bigActors at: i) whenResolved: [:farRef | bigActors at: i put: farRef] ].

      unwrapPromise whenResolved: [:r |
        sinkActor <-: neighbors: bigActors.
        bigActors do: [:n | n <-: neighbors: bigActors ].
        bigActors do: [:n | n <-: pong: -1 ]
      ].

      ^ completionPP promise
    )
    
    public verifyResult: result = (
      ^ result = numWorkers
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self numWorkers: (problem at: 1) asInteger
            numMessages: (problem at: 2) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '20000:120'
    )
  )

  (* === Savina Concurrency Benchmarks === *)

  public class ConcurrentDictionary numEntities: numEntities numMessages: numMessages writePercentage: writePercentage = Benchmark <: Value (
  | private numMessages = numMessages.
    private numEntities = numEntities.
    private writePercentage = writePercentage.
    private dataLimit = 512. (* 524287 / 1024,  Integer.MAX_VALUE / 4_096 TODO: this is not the same constant as originally! *)
  |
  )(
    class Master new: completionRes = (
    | private workers    = Array new: numEntities.
      private dictionary = (actors createActorFromValue: DictionaryActor) <-: new: completionRes.
      private numWorkersTerminated ::= 0.
    |
      start.
    )(
      private start = (
        workers doIndexes: [:i |
          | worker |
          worker := (actors createActorFromValue: Worker) <-: new: self dict: dictionary id: i.
          workers at: i put: worker.
          worker <-: doWork.
        ]
      )
      
      public endWork = (
        numWorkersTerminated := numWorkersTerminated + 1.
        numWorkersTerminated = numEntities ifTrue: [
          dictionary <-: endWork.
        ]
      )
    )
    
    class Worker new: master dict: dictionary id: id = (
    | private messageCount ::= 0.
      private random = Random new: id + numMessages + writePercentage.
      private master = master.
      private dictionary = dictionary.
    |
    )(
      public doWork = (
        messageCount := messageCount + 1.
        messageCount <= numMessages
          ifTrue: [
            | rnd |
            rnd := random next % 100.
            rnd < writePercentage
              ifTrue:  [ dictionary <-: write: self key: random next % dataLimit value: random next ]
              ifFalse: [ dictionary <-: read: self key: random next % dataLimit ] ]
          ifFalse: [ master <-: endWork ].
      )
      
      public result: value = (
        self doWork
      )
    )
    
    class DictionaryActor new: completionRes = (
    | private dataMap = self createDataMap: dataLimit.
      private completionRes = completionRes.
    |
    )(
      private createDataMap: dataLimit = (
        | dict |
        dict := Dictionary new: dataLimit.
        0 to: dataLimit - 1 do: [:i |
          dict at: i put: i
        ].
        ^ dict
      )
      
      public write: sender key: key value: val = (
        dataMap at: key put: val.
        sender <-: result: val
      )
      
      public read: sender key: key = (
        sender <-: result: (dataMap at: key)
      )
      
      public endWork = (
        completionRes resolve: dataMap size
      )
    )
  
    public benchmark = (
      | master completionPP |
      completionPP := actors createPromisePair.
      master := (actors createActorFromValue: Master) <-: new: completionPP resolver.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      ^ result = dataLimit
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self numEntities: (problem at: 1) asInteger
             numMessages: (problem at: 2) asInteger
         writePercentage: (problem at: 3) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '100:100:50'
    )
  )

  public class ConcurrentSortedLinkedList numWorkers: w numMessagesPerWorker: mw writePercentage: wp sizePercentage: sp = Benchmark <: Value (
  | private numWorkers           = w.
    private numMessagesPerWorker = mw.
    private writePercentage      = wp.
    private sizePercentage       = sp.
  |)(
    class Master new: completionRes = (
    | private workers    = Array new: numWorkers.
      private sortedList = (actors createActorFromValue: SortedList) <-: new: completionRes.
      private numWorkersTerminated ::= 0.
    |
      workers doIndexes: [:i |
        workers at: i put: ((actors createActorFromValue: Worker) <-: new: self sortedList: sortedList id: i).
        (workers at: i) <-: doWork.
      ]
    )(
      public endWork = (
        numWorkersTerminated := numWorkersTerminated + 1.
        numWorkersTerminated = numWorkers ifTrue: [
          sortedList <-: endWork
        ]
      )
    )
    
    class Worker new: master sortedList: sortedList id: id = (
    | private master = master.
      private sortedList = sortedList.
      private messageCount ::= 0.
      private random = Random new: id + numMessagesPerWorker + writePercentage + sizePercentage.
    |)(
      public endWork = (
        messageCount := messageCount + 1.
        master <-: endWork.
      )

      public doWork = (
        messageCount := messageCount + 1.
        messageCount <= numMessagesPerWorker
          ifTrue: [
            | anInt |
            anInt := random next % 100.
            anInt < sizePercentage
              ifTrue: [ sortedList <-: size: self.
                        ^ self ].
            anInt < (sizePercentage + writePercentage)
              ifTrue: [ sortedList <-: write: random next sender: self.
                        ^ self].
            sortedList <-: contains: random next sender: self ]
          ifFalse: [
            master <-: endWork
          ]
      )
      
      public result: val = (
        self doWork
      )
    )
    
    class SortedList new: completionRes = (
    | private completionRes = completionRes.
      private dataList = SortedLinkedList new.
    |)(
      public write: anInt sender: sender = (
        dataList add: anInt.
        sender <-: result: anInt
      )
      
      public contains: anInt sender: sender = (
        | result |
        result := dataList contains: anInt.
        sender <-: result: result.
      )
      
      public size: sender = (
        sender <-: result: dataList size
      )
      
      public endWork = (
        completionRes resolve: dataList size
      )
    )
    
    class SortedLinkedList = (
    | private head ::= nil.
      private iterator ::= nil.
    |)(
      class Node new: i = (
      | public item ::= i.
        public next ::= nil.
      |)()
      
      public isEmpty = ( ^ head isNil )
      
      public add: item = (
        | newNode after before |
        newNode := Node new: item.
        head ifNil: [
          head := newNode.
          ^ self ].

        item < head item ifTrue: [
          newNode next: head.
          head := newNode.
          ^ self ].
        
        after  := head next.
        before := head.
        
        [ after notNil and: [ item >= after item] ] whileTrue: [
          before := after.
          after  := after next.
        ].
        
        newNode next: before next.
        before next: newNode.
      )
      
      public contains: item = (
        | n |
        n := head.
        [ n notNil ] whileTrue: [
          item = n item ifTrue: [ ^ true ].
          n := n next.
        ].
        ^ false
      )
      
      public size = (
        | r n |
        r := 0.
        n := head.
        [ n notNil ] whileTrue: [
          r := r + 1.
          n := n next
        ].
        ^ r
      )
    )
  
    public benchmark = (
      | master completionPP |
      completionPP := actors createPromisePair.
      master := (actors createActorFromValue: Master) <-: new: completionPP resolver.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      (numWorkers = 10 and: [numMessagesPerWorker =   20 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result =   18 ].
      (numWorkers = 10 and: [numMessagesPerWorker =  100 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result =  106 ].
      (numWorkers = 10 and: [numMessagesPerWorker =  300 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result =  292 ].
      (numWorkers = 10 and: [numMessagesPerWorker =  500 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result =  476 ].
      (numWorkers = 10 and: [numMessagesPerWorker = 1000 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result =  992 ].
      (numWorkers = 10 and: [numMessagesPerWorker = 1500 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result = 1496 ].
      (numWorkers = 20 and: [numMessagesPerWorker = 1000 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result = 1959 ].
      (numWorkers = 20 and: [numMessagesPerWorker = 2000 and: [writePercentage = 10 and: [sizePercentage = 1]]]) ifTrue: [ ^ result = 3956 ].
      
      (* otherwise, warn that we don't know whether it is correct. *)
      ('---- result: ' + result asString + ' dont have a hardcoded verification result for this config yet') println.
      ^ false
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self        numWorkers: (problem at: 1) asInteger
          numMessagesPerWorker: (problem at: 2) asInteger
               writePercentage: (problem at: 3) asInteger
                sizePercentage: (problem at: 4) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '20:8000:10:1'
    )
  )

  public class ProducerConsumerBoundedBuffer bufferSize: bs numProducers: np numConsumers: nc numItemsPerProducer: ni = Benchmark <: Value (
  | private bufferSize   = bs.
    private numProducers = np.
    private numConsumers = nc.
    private numItemsPerProducer = ni.
    private prodCost     = 25.
    private consCost     = 25.
  |)(
    class Data new: datum from: sender = Value (
    | public datum  = datum.
      public sender = sender.|)()
    
    class ManagerActor new: completionRes = (
    | private adjustedBufferSize = bufferSize - numProducers.
      private availableProducers = Vector new.
      private availableConsumers = Vector new.
      private pendingData        = Vector new.
      private numTerminatedProducers ::= 0.
      private producers          = Array new: numProducers.
      private consumers          = Array new: numConsumers.
      private completionRes      = completionRes.
      private dataSum ::= 0.0.
    |
      producers doIndexes: [:i |
        | producer |
        producer := (actors createActorFromValue: ProducerActor) <-: new: i manager: self.
        producers at: i put: producer.
        producer <-: produceData.
      ].
      consumers doIndexes: [:i |
        | consumer |
        consumer := (actors createActorFromValue: ConsumerActor) <-: new: i manager: self.
        consumers at: i put: consumer.
        availableConsumers append: consumer.
      ]
    )(
      public data: datum from: producer = (
        dataSum := dataSum + datum.
        availableConsumers isEmpty
          ifTrue:  [ pendingData append: (Data new: datum from: producer) ]
          ifFalse: [ availableConsumers removeFirst <-: data: datum from: producer ].
        
        pendingData size >= adjustedBufferSize
          ifTrue:  [ availableProducers append: producer ]
          ifFalse: [ producer <-: produceData ]
      )
      
      public consume: consumer = (
        pendingData isEmpty
          ifTrue: [
            availableConsumers append: consumer.
            tryExit ]
          ifFalse: [
            | data |
            data := pendingData removeFirst.
            consumer <-: data: data datum from: data sender.
            availableProducers isEmpty ifFalse: [
              availableProducers removeFirst <-: produceData ] ].
      )
      
      public producerExit = (
        numTerminatedProducers := numTerminatedProducers + 1.
        tryExit
      )
      
      private tryExit = (
        (numTerminatedProducers = numProducers and: [availableConsumers size = numConsumers])
          ifTrue: [
            consumers do: [:c | c <-: exit ].
            completionRes resolve: dataSum ].
      )
    )
    
    class ProducerActor new: id manager: manager = (
    | private prodItem ::= 0.0.
      private itemsProduced ::= 0.
      private manager = manager.
    |)(
      private prodData = (
        prodItem := processItem: prodItem cost: prodCost.
        manager <-: data: prodItem from: self.
        itemsProduced := itemsProduced + 1.
      )
      
      public produceData = (
        itemsProduced < numItemsPerProducer
          ifTrue:  [ self prodData ]
          ifFalse: [ manager <-: producerExit ]
      )
    )
    
    class ConsumerActor new: id manager: manager = (
    | private consItem ::= 0.0.
      private manager = manager.
    |)(
      private consumeDataItem: dataToConsume = (
        consItem := processItem: consItem + dataToConsume cost: consCost.
      )
      
      public data: datum from: sender = (
        consumeDataItem: datum.
        manager <-: consume: self
      )
      
      public exit = ()
    )
    
    private processItem: curTerm cost: cost = (
      | res random |
      res    := curTerm.
      random := Random new: cost.
      
      cost > 0
        ifTrue: [
          cost timesRepeat: [
            100 timesRepeat: [
              res := res + (random nextDouble abs + 0.01) log ] ] ]
        ifFalse: [
          res := res + (random nextDouble abs + 0.01) log ].
      ^ res
    )
  
    public benchmark = (
      | manager completionPP |
      completionPP := actors createPromisePair.
      manager := (actors createActorFromValue: ManagerActor) <-: new: completionPP resolver.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      (bufferSize = 40 and: [numProducers = 10 and: [numConsumers = 10 and: [numItemsPerProducer =  60]]]) ifTrue: [^ result round =   -43522486].
      (bufferSize = 40 and: [numProducers = 10 and: [numConsumers = 10 and: [numItemsPerProducer =  80]]]) ifTrue: [^ result round =   -77056204].
      (bufferSize = 40 and: [numProducers = 20 and: [numConsumers = 20 and: [numItemsPerProducer =  80]]]) ifTrue: [^ result round =  -154112409].
      (bufferSize = 50 and: [numProducers = 20 and: [numConsumers = 20 and: [numItemsPerProducer = 100]]]) ifTrue: [^ result round =  -240206069].
      (bufferSize = 50 and: [numProducers = 40 and: [numConsumers = 40 and: [numItemsPerProducer = 100]]]) ifTrue: [^ result round =  -480412139].
      (bufferSize = 40 and: [numProducers = 10 and: [numConsumers = 10 and: [numItemsPerProducer = 600]]]) ifTrue: [^ result round = -4288035081].

      (* otherwise, warn that we don't know whether it is correct. *)
      ('---- result: ' + result asString + ' dont have a hardcoded verification result for this config yet') println.
      ^ false
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      
      ^ self bufferSize: (problem at: 1) asInteger
           numProducers: (problem at: 2) asInteger
           numConsumers: (problem at: 3) asInteger
    numItemsPerProducer: (problem at: 4) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '50:40:40:1000'
    )
  )

  public class Philosophers new: numPhil rounds: numRounds = Benchmark (
  | private numPhil   = numPhil.
    private numRounds = numRounds.
  |)(
    private class Counter = (
    | private value ::= 0. |
    )(
      public inc: anInt = ( value := value + anInt. )
      public get = ( ^ value )
    )
    
    private class PhilosopherActor new: id rounds: rounds counter: aCounter arbitrator: arbitrator = (
    | private localCounter ::= 0.
      private roundsSoFar  ::= 0.
      private id     = id.
      private rounds = rounds.
      private arbitrator = arbitrator.
      private counter    = aCounter.
    |)(
      public denied = (
        localCounter := localCounter + 1.
        arbitrator <-: hungry: self id: id.
      )
      
      public eat = (
        roundsSoFar := roundsSoFar + 1.
        localCounter > 0 ifTrue: [
          counter <-: inc: localCounter.
          localCounter := 0. ].
        
        arbitrator <-: done: id.
        roundsSoFar < rounds
          ifTrue:  [ self <-: start ]
          ifFalse: [ arbitrator <-: exit ]
      )
      
      public start = (
        arbitrator <-: hungry: self id: id.
      )
    )
    
    private class ArbitratorActor new: numForks resolver: resolver = (
    | private numForks = numForks.
      private forks    = Array new: numForks withAll: false.
      private numExitedPhilosophers ::= 0.
      private resolver = resolver.
    |)(
      public hungry: philosopher id: leftForkId = (
        | rightForkId |
        rightForkId := 1 + ((leftForkId + 1) % numForks).
        
        ((forks at: leftForkId) or: [forks at: rightForkId])
          ifTrue:  [ philosopher <-: denied ]
          ifFalse: [
            forks at: leftForkId  put: true.
            forks at: rightForkId put: true.
            philosopher <-: eat ]
      )
      
      public done: leftForkId = (
        | rightForkId |
        rightForkId := 1 + ((leftForkId) % numForks).
        
        forks at: leftForkId  put: false.
        forks at: rightForkId put: false.
      )
      
      public exit = (
        numExitedPhilosophers := numExitedPhilosophers + 1.
  
        numForks = numExitedPhilosophers ifTrue: [
          | forksTaken |
          forksTaken := 0.
          forks do: [:f | f ifTrue: [ forksTaken := forksTaken + 1 ] ].

          resolver resolve: forksTaken ]
      )
    )
    
    public benchmark = (
      | counter completionPP arbitrator philosophers |
      counter := Counter new.
      completionPP := actors createPromisePair.
      
      arbitrator := (actors createActorFromValue: ArbitratorActor) <-: new: numPhil resolver: completionPP resolver.
      philosophers := Array new: numPhil.
      philosophers doIndexes: [:i |
        | ph |
        ph := (actors createActorFromValue: PhilosopherActor) <-: new: i
                        rounds: numRounds counter: counter arbitrator: arbitrator.
        philosophers at: i put: ph ].
      
      philosophers do: [:ph | ph <-: start ].

      ^ completionPP promise
    )

    public verifyResult: result = (
      ^ result = 0
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      
      ^ self new: (problem at: 1) asInteger
          rounds: (problem at: 2) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '20:10000'
    )
  )

  public class SleepingBarber numHaircuts: numHaircuts waitingRoomSize: waitingRoomSize avProductionRate: avProductionRate avHaircutRate: avHaircutRate = Benchmark (
  | private numHaircuts      = numHaircuts.
    private waitingRoomSize  = waitingRoomSize.
    private avProductionRate = avProductionRate.
    private avHaircutRate    = avHaircutRate.
  |)(
    private class WaitingRoomActor new: capacity barber: anActor = (
    | private waitingCustomers = Vector new.
      private barberAsleep ::= true.
      private barber   = anActor.
      private capacity = capacity.
    |)(
      public enter: customer in: room = (
        waitingCustomers size = capacity
          ifTrue:  [ customer <-: full ]
          ifFalse: [
            waitingCustomers append: customer.
            barberAsleep
              ifTrue: [
                barberAsleep := false.
                self <-: next ]
              ifFalse: [
                customer <-: wait ] ]
      )

      public next = (
        waitingCustomers size > 0
          ifTrue: [
            | customer |
            customer := waitingCustomers removeFirst.
            barber <-: enter: customer in: self ]
          ifFalse: [
            barber <-: wait.
            barberAsleep := true ]
      )
      
      public exit = ( barber <-: exit )
    )

    private class BarberActor new: resolver = (
    | private random = Random new. 
      private resolver = resolver.
    |)(
      public enter: customer in: room = (
        room <-: next.
        customer <-: done.
        busyWait: (random next: avHaircutRate) + 10.
        customer <-: start.
      )
      
      private busyWait: limit = (
        | test |
        test := 0.
        limit timesRepeat: [
          random next.
          test := test + 1 ].
        ^ test
      )
      
      public wait = ()
      public exit = ( resolver resolve: random next )
    )
    
    private class CustomerFactoryActor new: numHaircuts room: room = (
    | private random = Random new.
      private numHaircuts = numHaircuts.
      private room = room.
      private numHaircutsSoFar ::= 0.
      private idGenerator ::= 0.
    |)(
      public start = (
        numHaircuts timesRepeat: [
          sendCustomerToRoom.
          busyWait: (random next: avHaircutRate) + 10 ].
      )
      
      private busyWait: limit = (
        | test |
        test := 0.
        limit timesRepeat: [
          random next.
          test := test + 1 ].
        ^ test
      )
      
      public returned: customer = (
        idGenerator := idGenerator + 1.
        sendCustomerToRoom: customer
      )
      
      public done = (
        numHaircutsSoFar := numHaircutsSoFar + 1.
        numHaircutsSoFar = numHaircuts ifTrue: [
          room <-: exit ]
      )
      
      private sendCustomerToRoom = (
        | customer |
        customer := (actors createActorFromValue: CustomerActor) <-: new: idGenerator factory: self.
        idGenerator := idGenerator + 1.
        sendCustomerToRoom: customer.
      )
      
      private sendCustomerToRoom: customer = (
        room <-: enter: customer in: room
      )
    )
    
    private class CustomerActor new: id factory: factoryActor = (
    | private factoryActor = factoryActor.
    |)(
      public full = ( factoryActor <-: returned: self )      
      public wait = ()
      public start= ()
      public done = ( factoryActor <-: done )
    )
    
    public benchmark = (
      | barber room factoryActor completionPP  |
      completionPP := actors createPromisePair.

      barber := (actors createActorFromValue: BarberActor) <-: new: completionPP resolver.
      room   := (actors createActorFromValue: WaitingRoomActor) <-: new: waitingRoomSize barber: barber.
      factoryActor := (actors createActorFromValue: CustomerFactoryActor) <-: new: numHaircuts room: room.
      
      factoryActor <-: start.

      ^ completionPP promise
    )

    public verifyResult: result = (
      (numHaircuts = 1000 and: [avHaircutRate =  500]) ifTrue: [ ^ result =  5029 ].
      (numHaircuts = 2500 and: [avHaircutRate =  500]) ifTrue: [ ^ result = 16033 ].
      (numHaircuts = 2500 and: [avHaircutRate = 1000]) ifTrue: [ ^ result = 32109 ].
      (numHaircuts = 5000 and: [avHaircutRate = 1000]) ifTrue: [ ^ result = 32109 ].
    
      ('no verification result for avHaircutRate: ' + avHaircutRate + ' result is: ' + result) println.
      ^ false
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      
      ^ self numHaircuts: (problem at: 1) asInteger
         waitingRoomSize: (problem at: 2) asInteger
        avProductionRate: (problem at: 3) asInteger
           avHaircutRate: (problem at: 4) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '5000:1000:1000:1000'
    )
  )
  
  public class CigaretteSmokers rounds: rounds smokers: smokers = Benchmark (
  | private rounds  = rounds.
    private smokers = smokers.
  |)(
    private class ArbiterActor new: numRounds smokers: numSmokers resolver: resolver = (
    | private numRounds  = numRounds.
      private numSmokers = numSmokers.
      private resolver   = resolver.
      
      private smokers = Array new: numSmokers withAll: [ (actors createActorFromValue: SmokerActor) <-: new: self ].
      private random  = Random new.
      private roundsSoFar ::= 0.
      private smokersExited ::= numSmokers.
    |)(
      public start = ( notifyRandomSmoker )
      
      public startedSmoking = (
        roundsSoFar := roundsSoFar + 1.
        roundsSoFar >= numRounds
          ifTrue:  [ requestSmokersToExit ]
          ifFalse: [ notifyRandomSmoker ]
      )
      
      private notifyRandomSmoker = (
        | newSmokerIndex busyWaitPeriod |
        newSmokerIndex := 1 + (random next abs) % numSmokers.
        busyWaitPeriod := 10 + (random next: 1000).
        (smokers at: newSmokerIndex) <-: startSmoking: busyWaitPeriod
      )
      
      private requestSmokersToExit = (
        smokers do: [:s | s <-: exit ]
      )
      
      public exited = (
        smokersExited := smokersExited - 1.
        smokersExited = 0 ifTrue: [
          resolver resolve: random next ]
      )
    )
    
    private class SmokerActor new: arbiterActor = (
    | private arbiterActor = arbiterActor.
      private random = Random new.
    |)(
      public startSmoking: busyWaitPeriod = (
        arbiterActor <-: startedSmoking.
        arbiterActor <-: startedSmoking.
        busyWait: busyWaitPeriod
      )
      
      private busyWait: limit = (
        | test |
        test := 0.
        limit timesRepeat: [
          random next.
          test := test + 1 ].
        ^ test
      )
      
      public exit = (
        arbiterActor <-: exited
      )
    )
  
    public benchmark = (
      | arbiterActor completionPP  |
      completionPP := actors createPromisePair.

      arbiterActor := (actors createActorFromValue: ArbiterActor) <-: new: rounds smokers: smokers resolver: completionPP resolver.
      arbiterActor <-: start.

      ^ completionPP promise
    )

    public verifyResult: result = (
      (rounds = 1000 and: [ smokers = 200 ]) ifTrue: [ ^ result = 50272 ].
      (rounds = 2000 and: [ smokers = 200 ]) ifTrue: [ ^ result = 11088 ].
      (rounds = 10000 and: [ smokers = 200 ]) ifTrue: [ ^ result = 53968 ].
      ('no verification result for rounds: ' + rounds + ' smokers: ' + smokers + ' result is: ' + result) println.
      ^ false
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      
      ^ self rounds: (problem at: 1) asInteger
            smokers: (problem at: 2) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '1000:200'
    )
  )

  public class LogisticsMapSeries numTerms: terms numSeries: series startRate: rate = Benchmark (
  | private numTerms  = terms.
    private numSeries = series.
    private startRate = rate.
    private increment = 0.0025.
  |)(
    class Master new: completionRes = (
    | private computers = Array new: numSeries.
      private workers   = Array new: numSeries.
      
      private numWorkRequested ::= 0.
      private numWorkReceived  ::= 0.
      private termsSum         ::= 0.0.

      private completionRes    = completionRes.
    |
      computers doIndexes: [:i |
        | rate i0 |
        i0 := i - 1.
        rate := startRate + (i0 * increment).
        computers at: i put: ((actors createActorFromValue: RateComputer) <-: new: rate) ].
      workers doIndexes: [:i |
        | rateComputer startTerm i0 |
        i0 := i - 1.
        rateComputer := computers at: i.
        startTerm    := i0 * increment.
        workers at: i put: ((actors createActorFromValue: SeriesWorker) <-: new: i master: self rateComputer: rateComputer startTerm: startTerm) ].
    )(
      public start = (
        1 to: numTerms do: [:i |
          workers do: [:w | w <-: nextTerm ] ].
        
        workers do: [:w |
          w <-: getTerm.
          numWorkRequested := numWorkRequested + 1 ]
      )
      
      public result: term = (
        termsSum := termsSum + term.
        numWorkReceived := numWorkReceived + 1.
        
        numWorkRequested = numWorkReceived ifTrue: [
          (* don't need to tell them to stop. will be GCed automatically. *)
          completionRes resolve: termsSum ]
      )
    )
    
    class SeriesWorker new: id master: master rateComputer: computer startTerm: startTerm = (
    | private curTerm ::= startTerm.
      private master   = master.
      private computer = computer.
      private waitingForReply ::= false.
      private waitingNextTerm ::= 0.
      private waitingGetTerm  ::= false.
    |)(
      public nextTerm = (
        waitingForReply
          ifTrue:  [ waitingNextTerm := waitingNextTerm + 1 ]
          ifFalse: [
            computer <-: compute: self term: curTerm.
            waitingForReply := true ]
      )
      
      public result: term = (
        waitingNextTerm > 0
          ifTrue: [
            waitingNextTerm := waitingNextTerm - 1.
            computer <-: compute: self term: term ]
          ifFalse: [
            curTerm := term.
            waitingForReply := false.
            waitingGetTerm ifTrue: [
              master <-: result: term ] ]
      )

      public getTerm = (
        waitingForReply
          ifTrue:  [ waitingGetTerm := true ]
          ifFalse: [ master <-: result: curTerm ]
      )
    )

    class RateComputer new: rate = (
    | private rate = rate. |
    )(
      public compute: sender term: term = (
        | res |
        res := rate * term * (1 - term).
        sender <-: result: res
      )
    )
  
    public benchmark = (
      | master completionPP |
      completionPP := actors createPromisePair.
      master := (actors createActorFromValue: Master) <-: new: completionPP resolver.
      master <-: start.
      ^ completionPP promise
    )
    public verifyResult: result = (
      | r |
      r := (result * 1000000) round.
      (numSeries = 10 and: [startRate = 3.46]) ifTrue: [ ^ r = 6387835 ].
      (numSeries = 20 and: [startRate = 3.46]) ifTrue: [ ^ r = 11022424 ].
      
      ('---- result: ' + r asString + ' dont have a hardcoded verification result for this config yet') println.
      ^ false
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      
      ^ self numTerms: (problem at: 1) asInteger
            numSeries: (problem at: 2) asInteger
            startRate: (problem at: 3) asInteger // 100
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '25000:10:346'
    )
  )

  public class BankTransaction numAccounts: acc numTransactions: tran = Benchmark (
  | private numAccounts     = acc.
    private numTransactions = tran. 
  |)(
    class Teller new: completionRes = (
    | private accounts = Array new: numAccounts.
      private numCompletedBankings ::= 0.
      private randomGen = Random new.
      private completionRes = completionRes.
      private transferredAmount ::= 0.0.
    |
      accounts doIndexes: [:i |
        accounts at: i put: ((actors createActorFromValue: Account) <-: new: i)]
    )(
      public start = (
        1 to: numTransactions do: [:i | generateWork ]
      )
      
      public reply: amount = (
        transferredAmount := transferredAmount + amount.
        numCompletedBankings := numCompletedBankings + 1.
        numCompletedBankings = numTransactions ifTrue: [
          completionRes resolve: transferredAmount.
        ]
      )

      private generateWork = (
        | srcAccountId loopId destAccountId srcAccount destAccount amount |
        srcAccountId := randomGen next: numAccounts / 10 * 8.
        loopId := randomGen next: numAccounts - srcAccountId.
        loopId = 0 ifTrue: [ loopId := loopId + 1 ].
        destAccountId := srcAccountId + loopId.
        
        srcAccount  := accounts at: srcAccountId + 1.
        destAccount := accounts at: destAccountId + 1.
        amount := (randomGen nextDouble abs) * 1000.

        srcAccount <-: credit: amount to: destAccount reply: self 
      )
    )

    class Account new: id = (
    | private balance ::= 0.0.
      private lastSender ::= nil.
      private waitingForReply ::= false.
      private requests = Vector new.
    |
    )(
      class Request credit: amount to: destAccount reply: sender = (
      | public amount = amount.
        public destAccount = destAccount.
        public sender = sender.
      |)()

      public debit: amount from: sender = (
        balance := balance + amount.
        sender <-: reply: amount.
      )
      
      private processCredit: amount to: destAccount reply: sender = (
        balance := balance - amount.
        destAccount <-: debit: amount from: self.
    
        lastSender := sender.
      )

      public credit: amount to: destAccount reply: sender = (
        waitingForReply
          ifTrue: [ requests append: (
            Request credit: amount to: destAccount reply: sender) ]
          ifFalse: [
            waitingForReply := true.
            processCredit: amount to: destAccount reply: sender
          ]
      )
      
      public reply: amount = (
        (*lastSender <-: reply: amount.*)
        requests isEmpty
          ifTrue: [ waitingForReply := false ]
          ifFalse: [
            | req |
            req := requests removeFirst.
            processCredit: req amount to: req destAccount reply: req sender
          ].
      )
    )

    public benchmark = (
      | master completionPP |
      completionPP := actors createPromisePair.
      master := (actors createActorFromValue: Teller) <-: new: completionPP resolver.
      master <-: start.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      | r |
      r := result round.
      
      numTransactions =   1000 ifTrue: [ ^ r = 516215    ].
      numTransactions =  10000 ifTrue: [ ^ r = 4975454   ].
      numTransactions =  50000 ifTrue: [ ^ r = 25057792  ].
      numTransactions = 100000 ifTrue: [ ^ r = 50038643  ].
      numTransactions = 500000 ifTrue: [ ^ r = 250052558 ].

      ('---- result: ' + r asString + ' dont have a hardcoded verification result for this config yet') println.
      ^ false
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      
      ^ self numAccounts: (problem at: 1) asInteger
         numTransactions: (problem at: 2) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '1000:50000'
    )
  )
  
  (* === Savina Parallelism Benchmarks === *)
  
  public class RadixSort numValues: numValues maxValue: maxValue seed: seed = Benchmark <: Value (
  | private numValues = numValues. 
    private maxValue  = maxValue.  (* Needs to be a power of 2, I think *)
    private seed      = seed.      (* Should probably be a prime number *)
  |
  )(
    class IntSourceActor = (
    | private random = Random new: seed. |
    ) (
      public next: actor = (
        1 to: numValues do: [:i |
          | candidate |
          candidate := (random next % maxValue) abs.
          actor <-: value: candidate.
        ]
      )
    )
  
    class SortActor new: radix next: nextActor = (
    | private radix     = radix.
      private next      = nextActor.
      
      private orderingArray = Array new: numValues withAll: 0.
      private valuesSoFar ::= 0.
      private j           ::= 1.
    |
    )(
      public value: current = (
        valuesSoFar := valuesSoFar + 1.
        
        (current & radix) = 0
          ifTrue:  [
           next <-: value: current ]
          ifFalse: [
            orderingArray at: j put: current.
            j := j + 1
          ].
        
        valuesSoFar = numValues ifTrue: [
          1 to: j - 1 do: [:i |
            next <-: value: (orderingArray at: i)
          ].
        ]
      )
    )
    
    class ValidationActor new: completionRes = (
    | private sumSoFar    ::=  0.
      private valuesSoFar ::=  0.
      private prevValue   ::=  0.
      private errorValue  ::= -1.
      private errorIdx    ::= -1.
      private completionRes = completionRes.
    |
    )(
      public value: val = (
        valuesSoFar := valuesSoFar + 1.
        
        (val < prevValue and: [errorValue < 0]) ifTrue: [
          errorValue := val.
          errorIdx   := valuesSoFar.
          system error: 'ERROR: Value out of place: ' + errorValue + ' at index ' + errorIdx
        ].
        
        prevValue := val.
        sumSoFar := sumSoFar + prevValue.
        
        valuesSoFar = numValues ifTrue: [
          errorValue >= 0
            ifTrue:  [ system error: 'Value out of place: ' + errorValue + ' at index ' + errorIdx ].
          completionRes resolve: sumSoFar
        ]
      )
    )
  
    public benchmark = (
      | validationActor sourceActor radix nextActor completionPP |
      completionPP := actors createPromisePair.
      validationActor := (actors createActorFromValue: ValidationActor) <-: new: completionPP resolver.
      sourceActor     := (actors createActorFromValue: IntSourceActor)  <-: new.
      
      radix := maxValue / 2.
      nextActor := validationActor.
      
      [radix > 0] whileTrue: [
        | sortActor |
        sortActor := (actors createActorFromValue: SortActor) <-: new: radix next: nextActor.
        
        radix := radix / 2.
        nextActor := sortActor
      ].
      
      sourceActor <-: next: nextActor.
      
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      (numValues =   100 and: [maxValue =   256 and: [seed = 74755]]) ifTrue: [ ^ result = 13606 ].
      (numValues = 10000 and: [maxValue = 65536 and: [seed = 74755]]) ifTrue: [ ^ result = 329373752 ].
      (numValues = 50000 and: [maxValue = 65536 and: [seed = 74755]]) ifTrue: [ ^ result = 1642300184 ].

      ('---- result: ' + result asString + ' dont have a hardcoded verification result for this config yet') println.
      ^ false
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self numValues: (problem at: 1) asInteger
              maxValue: (problem at: 2) asInteger
                  seed: (problem at: 3) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '100:256:74755'
    )
  )
  
  public class FilterBank = Benchmark ()( todo = () )
  
  public class Sieve new: limit local: numMaxLocalPrimes = Benchmark <: Value (
  | private limit = limit.
    private numMaxLocalPrimes = numMaxLocalPrimes.
  |
  )(
    class NumberProducerActor = ()(
      public produceNumbersFor: filterActor = (
        | candidate |
        candidate := 3.
        [candidate < limit] whileTrue: [
          filterActor <-: filter: candidate.
          candidate := candidate + 2
        ].
        
        filterActor <-: exit.
      )
    )
    
    class PrimeFilterActor new: id initialPrime: initialPrime resolver: completionRes = (
    | private id = id.
      private initialPrime = initialPrime.
      private nextFilterActor ::= nil.
      private localPrimes = Array new: numMaxLocalPrimes withAll: 0.
      private availableLocalPrimes ::= 1.
      private completionRes = completionRes.
    |
      localPrimes at: 1 put: initialPrime.
    )(
      private handleNewPrim: newPrim = (
        availableLocalPrimes < numMaxLocalPrimes
          ifTrue: [
            (* store locally if there is space *)
            availableLocalPrimes := availableLocalPrimes + 1.
            localPrimes at: availableLocalPrimes put: newPrim ]
          ifFalse: [
            (* create a new actor to store a new prime *)
            nextFilterActor := (actors createActorFromValue: PrimeFilterActor)
              <-: new: id + 1 initialPrime: newPrim resolver: completionRes
          ]
      )
      
      private isLocallyPrime: candidate = (
        1 to: availableLocalPrimes do: [:i |
          | remainder |
          remainder := candidate % (localPrimes at: i).
          remainder = 0 ifTrue: [ ^ false ]
        ].
        ^ true
      )
      
      public filter: candidate = (
        (isLocallyPrime: candidate)
          ifTrue: [
            nextFilterActor
              ifNil:    [handleNewPrim: candidate]
              ifNotNil: [nextFilterActor <-: filter: candidate]
          ]
      )
      public exit = (
        nextFilterActor
          ifNil: [
            | totalPrimes |
            totalPrimes := ((id - 1) * numMaxLocalPrimes) + availableLocalPrimes.
            completionPP resolve: totalPrimes ]
          ifNotNil: [ nextFilterActor <-: exit ]
      )
    )
   
    public benchmark = (
      | producerActor filterActor completionPP |
      completionPP := actors createPromisePair.
      producerActor := (actors createActorFromValue: NumberProducerActor) <-: new.
      filterActor   := (actors createActorFromValue: PrimeFilterActor)    <-: new: 1 initialPrime: 2 resolver: completionPP resolver.

      producerActor <-: produceNumbersFor: filterActor.
      
      ^ completionPP promise
    )
    
    public verifyResult: numberOfPrimes = (
      limit = 100    ifTrue: [ ^ numberOfPrimes =   25 ].
      limit = 1000   ifTrue: [ ^ numberOfPrimes =  168 ].
      limit = 10000  ifTrue: [ ^ numberOfPrimes = 1229 ].
      limit = 100000 ifTrue: [ ^ numberOfPrimes = 9592 ].
      (* otherwise, we don't know. *)
      ^ true 
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self new: (problem at: 1) asInteger
           local: (problem at: 2) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '100000:64'
    )
  )
  
  (* Compared to the Savina original benchmarks, this does not contain code for
     'urgent' nodes, which seemed broken in the original, at least I did not
     see that it was used. This version also uses explicit messages to
     have deterministic termination after the traversals is complete.
     It does not do an extra traversal for termination, since we already
     got the upward traversal after #traverse *)
  public class UnbalancedCobwebbedTree nodes: maxNodes binomial: numChildren avgCompSize: avg stdevCompSize: stdev = Benchmark <: Value (
  | private numChildren   = numChildren.
    private avgCompSize   = avg.
    private stdevCompSize = stdev.
    private maxNodes      = maxNodes.
  |)(
    class RootActor new: completionRes = (
    | private ran = Random new.
      private height ::= 1.
      private size   ::= 1.
      private children = Array new: numChildren.
      private hasGrantChildren = Array new: numChildren withAll: false.
      private traversedChildren ::= 0.
      private subtreeSize       ::= 0.
      private startedTraversal ::= false.
      private completionRes = completionRes.
    |)(
      public generateTree = (
        | computationSize i j |
        height := height + 1.
        computationSize := getNextNormal: avgCompSize with: stdevCompSize.

        1 to: numChildren do: [:i |
          | nodeActor |
          nodeActor := (actors createActorFromValue: NodeActor)
             <-: parent: self root: self height: height id: size + 1 computation: computationSize.
          children at: i put: nodeActor.
        ].
        
        size := size + numChildren.
        
        children do: [:c | c <-: tryGeneratedChildren ]
      )
      
      public shouldGenerateChildren: child height: childHeight = (
        size + numChildren <= maxNodes
          ifTrue: [
            | moreChildren |
            moreChildren := ran nextBoolean.
            moreChildren ifTrue: [
              | childComp randomInt |
              childComp := getNextNormal: avgCompSize with: stdevCompSize.
              child <-: generateChildren: size computation: childComp.
              size := size + numChildren.
              
              childHeight + 1 > height ifTrue: [ height := childHeight + 1 ].
            ] ifFalse: [
              childHeight > height ifTrue: [ height := childHeight ] ] ]
          ifFalse: [
            startedTraversal ifFalse: [
              startedTraversal := true.
              traverse ] ]
      )
      
      public traversed: treeSize = (
        traversedChildren := traversedChildren + 1.
        subtreeSize := subtreeSize + treeSize.

        traversedChildren = numChildren ifTrue: [
          completionRes resolve: subtreeSize.
        ]
      )
      
      public updateGrant: childId = (
        hasGrantChildren at: childId put: true
      )

      private getNextNormal: pMean with: pDev = (
        | result |
        result := 0.
        [ result <= 0 ] whileTrue: [
          | tempDouble |
          tempDouble := ran nextGaussian * pDev + pMean.
          result := tempDouble round
        ].
        ^ result
      )
      
      private traverse = (
        children do: [:c | c <-: traverse ].
      )
    )
    
    class NodeActor parent: parent root: root height: height id: id computation: compSize = (
    | private hasChildren ::= false.
      private traversedChildren ::= 0.
      private subtreeSize ::= 0.
      private children = Array new: numChildren.
      private hasGrantChildren = Array new: numChildren withAll: false.
      private busyLoopRan = Random new.
      
      private myParent   = parent.
      private myRoot     = root.
      private myHeight   = height.
      private myId       = id.
      private myCompSize = compSize.
    |)(
      public tryGeneratedChildren = (
        loop: avgCompSize / 50 with: busyLoopRan.
        myRoot <-: shouldGenerateChildren: self height: myHeight.
      )
      
      public generateChildren: currentId computation: compSize = (
        | myArrayId childrenHeight idValue |
        myArrayId := myId % numChildren.
        myParent <-: updateGrant: myArrayId.
        childrenHeight := myHeight + 1.
        idValue := currentId.
        
        1 to: numChildren do: [:i |
          | node |
          node := (actors createActorFromValue: NodeActor) <-: parent: self root: myRoot height: childrenHeight id: idValue + 1 computation: compSize.
          children at: i put: node.
        ].
        
        hasChildren := true.
        
        children do: [:c | c <-: tryGeneratedChildren ].
      )

      public updateGrant: childId = (
        hasGrantChildren at: childId put: true
      )
      
      public traverse = (
        traversedChildren := 0.
        loop: myCompSize with: busyLoopRan.
        hasChildren
          ifTrue:  [ children do: [:c | c <-: traverse ] ]
          ifFalse: [ myParent <-: traversed: 1 ].
      )
      
      public traversed: treeSize = (
        subtreeSize := subtreeSize + treeSize.
        traversedChildren := traversedChildren + 1.
        traversedChildren = numChildren ifTrue: [
          myParent <-: traversed: subtreeSize + 1.
        ]
      )

      private loop: times with: ran = (
        | result |
        result := 0.
        1 to: times do: [:k |
          result := ran next
        ].
        ^ result
      )
    )
    
    public benchmark = (
      | rootActor completionPP |
      completionPP := actors createPromisePair.
      rootActor := (actors createActorFromValue: RootActor) <-: new: completionPP resolver.
      rootActor <-: generateTree.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      ^ result = (maxNodes - numChildren)
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self   nodes: (problem at: 1) asInteger
            binomial: (problem at: 2) asInteger
         avgCompSize: (problem at: 3) asInteger
       stdevCompSize: (problem at: 4) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '200000:10:500:100'
    )
  )

  public class TrapezoidalApproximation numWorkers: w numPieces: n left: l right: r = Benchmark <: Value (
  | private numWorkers = w.
    private numPieces  = n.
    private left       = l.
    private right      = r.
    private precision  = (r - l) // n.
  |)(
    class Master new: completionRes = (
    | private workers = Array new: numWorkers withAll: ((actors createActorFromValue: Worker) <-: new: self).
      private completionRes    = completionRes.
      private numTermsReceived ::= 0.
      private resultArea       ::= 0.0.
    |)(
      public result: result = (
        numTermsReceived := numTermsReceived + 1.
        resultArea := resultArea + result.
        
        numTermsReceived = numWorkers ifTrue: [
          completionRes resolve: resultArea ]
      )
      
      public work: l and: r and: h = (
        | workerRange |
        workerRange := (r - l) // numWorkers.
        workers doIndexes: [:i |
          | wl wr |
          wl := (workerRange * (i - 1.0)) + l.
          wr := wl + workerRange.
          (workers at: i) <-: work: wl and: wr and: h
        ]
      )
    )
    
    class Worker new: master = (
    | private master = master.
    |)(
      public work: l and: r and: h = (
        | n accumArea |
        n := (r - l) // h.
        accumArea := 0.0.
        
        0 to: n - 1 do: [:i |
          | lx rx ly ry area |
          lx := (i * h) + l.
          rx := lx + h.
          
          ly := fx: lx.
          ry := fx: rx.
          
          area := 0.5 * (ly + ry) * h.
          accumArea := accumArea + area.
        ].
        
        master <-: result: accumArea
      )
      
      private fx: x = (
        | a b c d r |
        a := ((x * x * x) - 1.0) sin.
        b := x + 1.0.
        c := a // b.
        d := (1.0 + (2.0 * x) sqrt exp) sqrt.
        r := c * d.
        ^ r
      )
    )
    
    public benchmark = (
      | master completionPP |
      completionPP := actors createPromisePair.
      master := (actors createActorFromValue: Master) <-: new: completionPP resolver.
      master <-: work: left and: right and: precision.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      | r |
      r := (result * 100000000) round.
      (numWorkers = 100 and: [numPieces =    2500 and: [left = 1 and: [right = 5]]]) ifTrue: [ ^ r = 27107880 ].
      (numWorkers = 100 and: [numPieces =    5000 and: [left = 1 and: [right = 5]]]) ifTrue: [ ^ r = 27108026 ].
      (numWorkers = 100 and: [numPieces =   10000 and: [left = 1 and: [right = 5]]]) ifTrue: [ ^ r = 27108063 ].
      (numWorkers = 100 and: [numPieces =  100000 and: [left = 1 and: [right = 5]]]) ifTrue: [ ^ r = 27108075 ].
      (numWorkers = 100 and: [numPieces = 1000000 and: [left = 1 and: [right = 5]]]) ifTrue: [ ^ r = 27108075 ].
    
      (* otherwise, warn that we don't know whether it is correct. *)
      ('---- result: ' + r asString + ' dont have a hardcoded verification result for this config yet') println.
      ^ false
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self numWorkers: (problem at: 1) asInteger
              numPieces: (problem at: 2) asInteger
                   left: (problem at: 3) asInteger * 1.0
                  right: (problem at: 4) asInteger * 1.0
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '100:10000000:1:5'
    )
  )
  
  
  public class SuccessiveOverRelaxation = Benchmark ()( todo = ( USES_SHARED_ARRAYS ) )

  (* This benchmark uses originally shared grid nodes.
     The interesting property is that the updates are conceptually safe even
     when they are racy. The benchmark just tries to establish the parent
     relationship. However, we actually need the information about whether we
     succeeded with the update to determine which actor should continue
     processing the updated node.
  
     For this version, we will use Grid actors that actually hold the grid nodes
     to avoid sequentializing the access during the search phase.
  
     Note further, that the #search:target: method is much more complex since
     it is needs to be fully asynchronous.
     The #initializeData method is also more complex. I unrolled the loop to
     avoid the complexity of having to handle the asynchronicity there as well.
  
     Another critical difference is that we do not calculate the distance from
     root, because it is not used. And pretty annoying to implement properly
     synchronized. Which it isn't in the original code either.
     Also, FarRefs are not polymorphic with local refs, which makes this very
     strange.
   *)
  public class AStarSearch numWorkers: numWorkers gridSize: gridSize = Benchmark <: Value (
  | private numWorkers = numWorkers.
    private gridSize   = gridSize.
    private threshold  = 1024. |
  )(
    class GridNode id: id i: i j: j k: k = (
    | public id = id.
      public i  = i.
      public j  = j.
      public k  = k.
      private neighbors = Vector new.
      public parentInPath ::= nil.
      public distanceFromRoot ::= 0.
    | 
      clearParentAndDistance.
    )(
      public clearParentAndDistance = (
        parentInPath     := nil.
        distanceFromRoot := id = 1 ifTrue: [0] ifFalse: [-1].
      )

      private addNeighbor: node = (
        node == self ifTrue: [ ^ false ].
        neighbors do: [:n | n == node ifTrue: [ ^ false ] ].

        neighbors append: node.
        ^ true
      )
      
      public addNeighborsA: a b: b c: c d: d e: e f: f addA: addA addB: addB addC: addC addD: addD addE: addE addF: addF = (
        | addedNeighbor |
        addedNeighbor := false.
  
        addA ifTrue: [ (addNeighbor: a) ifTrue: [ addedNeighbor := true ] ].
        addB ifTrue: [ (addNeighbor: b) ifTrue: [ addedNeighbor := true ] ].
        addC ifTrue: [ (addNeighbor: c) ifTrue: [ addedNeighbor := true ] ].
        addD ifTrue: [ (addNeighbor: d) ifTrue: [ addedNeighbor := true ] ].
        addE ifTrue: [ (addNeighbor: e) ifTrue: [ addedNeighbor := true ] ].
        (addedNeighbor not or: [addF])
          ifTrue: [ addNeighbor: f ].
      )
      
      public numNeighbors = (
        ^ neighbors size
      )
      
      public neighbor: id = (
        ^ neighbors at: id
      )
      
      public setParent: node = (
        parentInPath == nil ifFalse: [ ^ false ].
        
        parentInPath := node.
        
        (* node could be a far reference here, not sure how to get this right:
           distanceFromRoot := node distanceFromRoot + (distanceFrom: node). *)
        ^ true
      )
      
      private distanceFrom: node = (
        (* Not implemented!
         | iDiff jDiff kDiff |
        iDiff := i - node i.
        jDiff := j - node j.
        kDiff := k - node k.
        ^ ((iDiff * iDiff) + (jDiff * jDiff) + (kDiff * kDiff)) sqrt round *)
        ^ self
      )
    )
  
    class Master new: completionRes = (
    | private workers = Array new: numWorkers withAll: [(actors createActorFromValue: Worker) <-: new: self].
      private numWorkersTerminated ::= 0.
      private numWorkSent          ::= 0.
      private numWorkCompleted     ::= 0.
      private allNodes = Array new: gridSize * gridSize * gridSize.
      private completionRes = completionRes.
    |
      initializeData whenResolved: [:r | sendWork: originNode target: targetNode ]
    )(
      private originNode = (
        ^ allNodes at: 1
      )
      
      private targetNode = (
        | axisVal targetId |
        axisVal := (0.8 * gridSize) round.
        targetId := (axisVal * gridSize * gridSize) + (axisVal * gridSize) + axisVal + 1.
        ^ allNodes at: targetId
      )
      
      private sendWork: origin target: target = (
        | workerIdx |
        workerIdx := numWorkSent % numWorkers + 1.
        numWorkSent := numWorkSent + 1.
        (workers at: workerIdx) <-: work: origin target: target.
      )
      
      private createGridNodes: gridActors = (
        | id gs1 |
        gs1 := gridSize - 1. (* for offset-based numbers *)
        id := 1.
        ^ actors async: 0 to: gs1 do: [:i |
          | gridActor |
          gridActor := gridActors at: (i / 3) + 1.
          
          actors async: 0 to: gs1 do: [:j |
            actors async: 0 to: gs1 do: [:k |
              (gridActor <-: id: id i: i j: j k: k) whenResolved: [:gridNode |
                allNodes at: id put: gridNode.
                id := id + 1 ] ] ] ].
      )
      
      private setNeighbors = (
        | random id gs1 g2 |
        gs1 := gridSize - 1. (* for offset-based numbers *)
        g2 := gridSize * gridSize.
        
        random := Random new.
        id := 1.
        
        (* We unrolled this loop to avoid having to rewrite it with #whenResolved callbacks.
           This is certainly not nice code, and not idiomatic either...
        
        | iterCount neighborCount |
        iterCount     := 0.
        neighborCount := 0.
        
         0 to: 1 do: [:i |
          0 to: 1 do: [:j |
            0 to: 1 do: [:k |
              iterCount := iterCount + 1.
              iterCount = 1 or: [iterCount = 8] ifFalse: [
                | addNeighbor |
                addNeighbor := (iterCount = 7 and: [neighborCount = 0]) or: [random nextBoolean].
                addNeighbor ifTrue: [
                  | newI newJ newK newId newNode |
                  newI := (gridSize - 1) min: (gridNode i + i).
                  newJ := (gridSize - 1) min: (gridNode j + j).
                  newK := (gridSize - 1) min: (gridNode k + k).
                  newId := (gridSize * gridSize * newI) + (gridSize * newJ) + newK + 1.
                  newNode := allNodes at: newId.
                
                  (gridNode addNeighbor: newNode)
                    ifTrue: [ neighborCount := neighborCount + 1 ] ] ] ] ] ] ]. *)
        
        0 to: gs1 do: [:i |
          0 to: gs1 do: [:j |
            0 to: gs1 do: [:k |
              (allNodes at: id) <-: addNeighborsA: (allNodes at: (g2 * (gs1 min: i    ))
                                                         + (gridSize * (gs1 min: j    ))
                                                         +             (gs1 min: k + 1) + 1)
                                                b: (allNodes at: (g2 * (gs1 min: i    ))
                                                         + (gridSize * (gs1 min: j + 1))
                                                         +             (gs1 min: k    ) + 1)
                                                c: (allNodes at: (g2 * (gs1 min: i    ))
                                                         + (gridSize * (gs1 min: j + 1))
                                                         +             (gs1 min: k + 1) + 1)
                                                d: (allNodes at: (g2 * (gs1 min: i + 1))
                                                         + (gridSize * (gs1 min: j    ))
                                                         +             (gs1 min: k    ) + 1)
                                                e: (allNodes at: (g2 * (gs1 min: i + 1))
                                                         + (gridSize * (gs1 min: j    ))
                                                         +             (gs1 min: k + 1) + 1)
                                                f: (allNodes at: (g2 * (gs1 min: i + 1))
                                                         + (gridSize * (gs1 min: j + 1))
                                                         +             (gs1 min: k    ) + 1)
                                                addA: random nextBoolean
                                                addB: random nextBoolean
                                                addC: random nextBoolean
                                                addD: random nextBoolean
                                                addE: random nextBoolean
                                                addF: random nextBoolean.
              id := id + 1 ] ] ]
      )

      private initializeData = (
        | gridActors |
        gridActors := Array new: (gridSize / 3) + 1 withAll: [actors createActorFromValue: GridNode].
        
        ^ (createGridNodes: gridActors) whenResolved: [:r |
          setNeighbors.
          allNodes do: [:gridNode |
            (* This does not need synchronization, because we rely on the fact
               that message order is guaranteed from the same sending actor,
               and that the addNeighbors* message doesn't do any message sending
               either. *)
            gridNode <-: clearParentAndDistance ] ]
      )
      
      public work: origin target: target = (
        sendWork: origin target: target
      )
      
      public received = (
        numWorkCompleted := numWorkCompleted + 1.
        numWorkCompleted = numWorkSent ifTrue: [
          requestWorkersToStop ]
      )
      
      public done = (
        requestWorkersToStop
      )
      
      public stop = (
        numWorkersTerminated := numWorkersTerminated + 1.
        numWorkersTerminated = numWorkers ifTrue: [
          completionRes resolve: validate
        ]
      )
      
      private validate = (
        | parentNode nextProm next loop |
        loop := actors createPromisePair.
        parentNode := targetNode.
        
        nextProm := parentNode <-: parentInPath.
        nextProm whenResolved: [:next |
          | n |
          n := next.
          loop resolve: (actors async: [(n == nil) not] whileTrue: [
            parentNode := n.
            (parentNode <-: parentInPath) whenResolved: [:nn | n := nn] ]) ].
        
        ^ loop promise whenResolved: [:r | parentNode == originNode]
      )
      
      private requestWorkersToStop = (
        workers do: [:w | w <-: stop ]
      )
    )

    class Worker new: master = (
    | private master = master.
      private random = Random new. |
    )(
      private busyLoop = (
        1 to: 100 do: [:i | random next ]
      )
    
      public work: origin target: target = (
        (search: origin target: target)
          whenResolved: [:r | master <-: received ]
      )

      public stop = (
        master <-: stop
      )
      
      private search: origin target: target = (
        | workQueue nodesProcessed continue outerLoopProm |
        workQueue := Vector new.
        workQueue append: origin.
        continue := true.
        
        nodesProcessed := 0.
        
        outerLoopProm := actors async: [
          workQueue isEmpty not and: [nodesProcessed < threshold and: continue]] whileTrue: [
          | loopNode numNeighbors outerIterationDone |
          outerIterationDone := actors createPromisePair.
          nodesProcessed := nodesProcessed + 1.
          busyLoop.
          
          loopNode := workQueue removeFirst.
          (loopNode <-: numNeighbors) whenResolved: [:numNeighbors |
            | i whileCompletionPromise |
            i := 1.

            whileCompletionPromise := actors async: [i <= numNeighbors and: continue] whileTrue: [
              | iterationDone |
              iterationDone := actors createPromisePair.
              
              (loopNode <-: neighbor: i) whenResolved: [:loopNeighbor |
                (loopNeighbor <-: setParent: loopNode)
                  whenResolved: [:success |
                    success ifTrue: [
                      loopNeighbor == target ifTrue: [
                        master <-: done.
                        continue := false
                      ] ifFalse: [
                        workQueue append: loopNeighbor ] ].
                    i := i + 1.
                    iterationDone resolve: nil ] ].
              iterationDone promise ].
            outerIterationDone resolve: whileCompletionPromise ].
          outerIterationDone promise ].
        
        ^ outerLoopProm whenResolved: [:r |
          [workQueue isEmpty] whileFalse: [
            master <-: work: workQueue removeFirst target: target ] ]
      )
    )
  
    public benchmark = (
      | completionPP |
      completionPP := actors createPromisePair.
      (actors createActorFromValue: Master) <-: new: completionPP resolver.
      ^ completionPP promise
    )
    
    public verifyResult: aBool = (
      ^ aBool
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self numWorkers: (problem at: 1) asInteger
               gridSize: (problem at: 2) asInteger
    )
    
    public setupVerifiedRun: run = (
      self todo.
      run problemSize: '100:100'
    )
  )

  public class NQueens numWorkers: workers size: size threshold: threshold = Benchmark (
  | private numWorkers = workers.
    private size       = size.
    private threshold  = threshold.
  |)(
    public class Master new: completionRes = (
    | private workers = Array new: numWorkers.
      private messageCounter ::= 0.
      private resultCounter  ::= 0.
      private numWorkSent    ::= 0.
      private numWorkCompleted ::= 0.
      private completionRes = completionRes.
    |
      1 to: numWorkers do: [:i |
        workers at: i put: ((actors createActorFromValue: Worker) <-: new: self)].
      
      send: (TransferArray new: 0) depth: 0
    )(
      private send: arr depth: depth = (
        messageCounter := messageCounter + 1.
        (workers at: messageCounter) <-: work: arr depth: depth.
        messageCounter := messageCounter % numWorkers.
        numWorkSent := numWorkSent + 1.
      )
      
      public work: arr depth: depth = (
        send: arr depth: depth
      )
      
      public result = (
        resultCounter := resultCounter + 1.
      )
      
      public done = (
        numWorkCompleted := numWorkCompleted + 1.
        numWorkCompleted = numWorkSent ifTrue: [
          completionRes resolve: resultCounter
        ]
      )
    )
    
    public class Worker new: master = (
    | private master = master. |
    )(
      public work: arr depth: depth = (
        nqueensKernelPar: arr depth: depth.
        master <-: done
      )
      
      private nqueensKernelPar: arr depth: depth = (
        size = depth ifTrue: [
          master <-: result.
          ^ self
        ].
        
        depth >= threshold ifTrue: [
          nqueensKernelSeq: arr depth: depth.
          ^ self
        ].
        
        distributeWork: arr depth: depth
      )
      
      private distributeWork: arr depth: depth = (
        | newDepth |
        newDepth := depth + 1.
      
        0 to: size - 1 do: [:i |
          | b |
          b := TransferArray new: newDepth withAll: 0.
          arr copyFrom: 1 to: depth to: b.
          b at: newDepth put: i.
          (board: b valid: newDepth) ifTrue: [
            master <-: work: b depth: newDepth ] ]
      )
      
      private nqueensKernelSeq: arr depth: depth = (
        | b newDepth |
        size = depth ifTrue: [
          master <-: result.
          ^ self ].
        
        newDepth := depth + 1.
        b := TransferArray new: newDepth.
        0 to: size - 1 do: [:i |
          arr copyFrom: 1 to: depth to: b.
          b at: newDepth put: i.
          (board: b valid: newDepth) ifTrue: [
            nqueensKernelSeq: b depth: newDepth ] ]
      )
      
      private board: arr valid: n = (
        1 to: n do: [:i |
          | p |
          p := arr at: i.
          i + 1 to: n do: [:j |
            | q |
            q := arr at: j.
            (q = p or: [q = (p - (j - i)) or: [q = (p + (j - i))]]) ifTrue: [ ^ false ] ] ].
        ^ true
      )
    )
    
    public benchmark = (
      | master completionPP |
      completionPP := actors createPromisePair.
      master := (actors createActorFromValue: Master) <-: new: completionPP resolver.
      ^ completionPP promise
    )
    
    public verifyResult: result = (
      size =  1 ifTrue: [ ^ result = 1           ].
      size =  2 ifTrue: [ ^ result = 0           ].
      size =  3 ifTrue: [ ^ result = 0           ].
      size =  4 ifTrue: [ ^ result = 2           ].
      size =  5 ifTrue: [ ^ result = 10          ].
      size =  6 ifTrue: [ ^ result = 4           ].
      size =  7 ifTrue: [ ^ result = 40          ].
      size =  8 ifTrue: [ ^ result = 92          ].
      size =  9 ifTrue: [ ^ result = 352         ].
      size = 10 ifTrue: [ ^ result = 724         ].
      size = 11 ifTrue: [ ^ result = 2680        ].
      size = 12 ifTrue: [ ^ result = 14200       ].
      size = 13 ifTrue: [ ^ result = 73712       ].
      size = 14 ifTrue: [ ^ result = 365596      ].
      size = 15 ifTrue: [ ^ result = 2279184     ].
      size = 16 ifTrue: [ ^ result = 14772512    ].
      size = 17 ifTrue: [ ^ result = 95815104    ].
      size = 18 ifTrue: [ ^ result = 666090624   ].
      size = 19 ifTrue: [ ^ result = 4968057848  ].
      size = 20 ifTrue: [ ^ result = 39029188884 ].

      ('---- result: ' + result asString + ' dont have a hardcoded verification result for this config yet') println.
      ^ false
    )
  ) : (
    public newInstance: problemSize = (
      | problem |
      problem := problemSize split: ':'.
      ^ self numWorkers: (problem at: 1) asInteger
                   size: (problem at: 2) asInteger
              threshold: (problem at: 3) asInteger
    )
    
    public setupVerifiedRun: run = (
      run problemSize: '20:12:4'
    )
  )
)
