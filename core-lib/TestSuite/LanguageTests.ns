class LanguageTests usingPlatform: platform testFramework: minitest = Value (
| private TestContext  = minitest TestContext.
  private Array        = platform kernel Array.
  private ValueArray   = platform kernel ValueArray.
  private ObjectMirror = platform mirrors ObjectMirror.
  private Set          = platform collections Set.
  private kernel       = platform kernel.
  private NotAValue    = platform kernel NotAValue.
  private langTestsModule = self.
|
)(
  (* This test verifies that SOM blocks are indeed closures.
     The test was found on Eliot Miranda's Cog Blog. *)

  public class ClosureTest = TestContext ()(
    public testClosureProperty = (
      | factorial result facs |

      facs:: Array new: 10.
      facs at: 1 put: 1.
      facs at: 2 put: 2.
      facs at: 3 put: 6.
      facs at: 4 put: 24.
      facs at: 5 put: 120.
      facs at: 6 put: 720.
      facs at: 7 put: 5040.
      facs at: 8 put: 40320.
      facs at: 9 put: 362880.
      facs at: 10 put: 3628800.

      factorial:: [ :n |
          n = 1
              ifTrue: [ 1 ]
              ifFalse: [ (factorial value: n - 1) * n ] ].

      result:: (1 to: 10) collect: factorial.
      result doIndexes: [ :i |
        self assert: (facs at: i) equals: (result at: i) ]
    )
  ) : ( TEST_CONTEXT = () )

  public class SelfBlockTest = TestContext ()(

    public testEscapedBlock = (
      self assert: 42 equals: self give42 value
    )

    give42 = (
      ^[ self giveBlock value ]
    )

    giveBlock = (
      ^self returnBlock value
    )

    returnBlock = (
      ^[ self returnBlock2 value ]
    )

    returnBlock2 = (
      ^[ 42 ]
    )
  ) : ( TEST_CONTEXT = () )

  public class BlockTest = TestContext (
    | escapeCount anEscapedBlock |
  ) (

    simpleBlock = (
      ^[42]
    )

    incBlock = (
      ^[ :val | val + 1]
    )

    (* This requires a closure *)
    adderBlock: amount = (
      ^[ :val | amount + val]
    )

    (* Closure with mutable state in block *)
    counterBlock = (
      |count|
      count:: 0.
      ^[count:: count + 1. count]
    )

    public selfKeeper = (
      ^[self]
    )

    escapingBlock = (
      ^[^42]
    )

    manyArguments = (
      ^[ :arg1 :arg2 :arg3 :arg4 |
        (arg1 + arg2 + arg3 + arg4)
      ]
    )

    public testSimpleBlocks = (
      self assert: 42 equals: self simpleBlock value.
      self assert: 4  equals: (self incBlock value: 3).
      self assert: 43 equals: ((self adderBlock: 13) value: 30).
    )

    public testClosure = (
      | counter |
      counter:: self counterBlock.
      self assert: 1 equals: counter value.
      self assert: 2 equals: counter value.
      self assert: 1 equals: self counterBlock value. (* make sure each copy is independent *)
      self assert: 3 equals: counter value.
    )

    public testSelfInBlock = (
      | testInst |
      testInst:: BlockTest new.
      self assert: testInst is: testInst selfKeeper value.
      self assert: self     is: self selfKeeper value.
    )

    public testValueWithArguments = (
      self assert: 18 equals: (self manyArguments valueWithArguments: { 3 . 4 . 5 . 6 }).
      self assert: 42 equals: (self simpleBlock valueWithArguments: (Array new: 0)).
      self assert: 4  equals: (self incBlock valueWithArguments: { 3 }).
    )

    public testBlockArgumentErrors = (
      [ self simpleBlock value: 1.
        self assert: false.
      ] on: kernel ArgumentError do: [:e | ].
      
      [ self manyArguments value.
        self assert: false.
      ] on: kernel ArgumentError do: [:e | ].

      [ self incBlock valueWithArguments: (Array new: 0). 
        self assert: false.
      ] on: kernel ArgumentError do: [:e | ].
    )

    public testEscapedBlock = (
      | escapingBlock |

      escapeCount:: 0.

      escapingBlock:: self escapingBlock.

      self assert: 0 equals: escapeCount.
      self assert: 666 equals: escapingBlock value.
      self assert: 1 equals: escapeCount.

      self assert: escapingBlock is: anEscapedBlock.
    )

    escapedBlock: block = (
      escapeCount:: escapeCount + 1.
      anEscapedBlock:: block.

      (* return some dummy value to the object that sent 'value' to block *)
      ^666
    )
  ) : ( TEST_CONTEXT = () )

  public class SuperTestSuperClass = TestContext ()(
    give42 = ( ^42 )
    something = ( ^ #super )
  )

  public class SuperTest = SuperTestSuperClass ()(

    public testSuper = (
      self assert: 42 equals: self give42.
      self assert: 42 equals: self blockGive42.
    )

    give42 = (
      ^ super give42
    )

    blockGive42 = (
      ^ [ super give42 ] value
    )

    something = (
      ^ #sub
    )
  ) : ( TEST_CONTEXT = () )

  public class CompilerReturnTest = TestContext ()(

    return1 = ( ^self )
    return2 = (       )

    return3: arg = ( ^self )
    return4: arg = (       )

    public testExplicitAndImplicitReturns = (
      self assert: self is: self return1.
      self assert: self is: self return2.
      self assert: self is: (self return3: 23).
      self assert: self is: (self return4: 23).
    )

    (* In SOM++, code after the #ifTrue: does not seem to be executed, if the
       block expression ends with a dot. *)
    public testIfTrueWithDot = (
      | arr |
      arr:: Array new: 3.
      self usesIfTrueWithDot: arr.
      self assertArrayCorrectness: arr.
    )

    assertArrayCorrectness: arr = (
      self assert: 1 equals: (arr at: 1). (* method was not executed *)
      self assert: 2 equals: (arr at: 2). (* ifTrue was not executed *)
      self assert: 3 equals: (arr at: 3). (* remainder was not executed *)
    )

    public testIfTrueWithoutDot = (
      | arr |
      arr:: Array new: 3.
      self usesIfTrueWithoutDot: arr.
      self assertArrayCorrectness: arr.
    )

    public testIfFalseWithDot = (
      | arr |
      arr:: Array new: 3.
      self usesIfFalseWithDot: arr.
      self assertArrayCorrectness: arr.
    )

    public testIfFalseWithoutDot = (
      | arr |
      arr:: Array new: 3.
      self usesIfFalseWithoutDot: arr.
      self assertArrayCorrectness: arr.
    )

    usesIfTrueWithDot: arr = (
      arr at: 1 put: 1.
      (3 >= 1) ifTrue: [arr at: 2 put: 2. ]. 'WITH DOT'.
      arr at: 3 put: 3.
    )

    usesIfTrueWithoutDot: arr = (
      arr at: 1 put: 1.
      (3 >= 1) ifTrue: [arr at: 2 put: 2 ]. 'WITHOUT DOT'.
      arr at: 3 put: 3.
    )

    usesIfFalseWithDot: arr = (
      arr at: 1 put: 1.
      (3 >= 1) ifTrue: [arr at: 2 put: 2. ]. 'WITH DOT'.
      arr at: 3 put: 3.
    )

    usesIfFalseWithoutDot: arr = (
      arr at: 1 put: 1.
      (3 >= 1) ifTrue: [arr at: 2 put: 2 ]. 'WITHOUT DOT'.
      arr at: 3 put: 3.
    )
  ) : ( TEST_CONTEXT = () )

  class DoesNotUnderstandMessage to: target selector: selector arguments: args = (
    | public target   = target.
      public selector = selector.
      public arguments = args.
    |
  )()

  public class DoesNotUnderstandTest = TestContext ()(

    public testSimpleUnknownFoo = (
      | result |
      result:: self foo.
      self assert: self is: result target.
      self assert: #foo equals: result selector.
    )

    public testArguments = (
      | result |
      result:: self foo.
      self assert: 0 equals: result arguments size.

      result:: self foo: 1.
      self assert: 1 equals: result arguments size.
      self assert: 1 equals: (result arguments at: 1).

      result:: self foo: 1 bar: 2 baz: 3.
      self assert: 3 equals: result arguments size.
      self assert: 1 equals: (result arguments at: 1).
      self assert: 2 equals: (result arguments at: 2).
      self assert: 3 equals: (result arguments at: 3).
    )

    public testRepeat = (
      | result |
      result:: Array new: 5.
      1 to: result size do: [:i |
        result at: i put: self foo.

        i > 1 ifTrue: [
          self assert: (result at: i - 1) ~= (result at: i).
        ]
      ].
    )

    doesNotUnderstand: selector arguments: arguments = (
      ^ DoesNotUnderstandMessage to: self selector: selector arguments: arguments.
    )
  ) : ( TEST_CONTEXT = () )

  public class ClassA = (
    | a b |
  ) (
    result = ( ^ 42 )
  )

  public class ClassB = ClassA (
    | c d |
  ) ( )

  public class ClassC = ClassB (
    | e f |
  ) (
    public getA      = ( ^ a )
    public setA: val = ( a:: val )

    public getF      = ( ^ f )
    public setF: val = ( f:: val )
  )

  public class ClassStructureTest = TestContext ()(
    class Root = (| public a ::= 1. |)()
    class Sub  = Root (| public a ::= 2. |)( public superA = ( ^ super a ) )

    public testSuperClassSlot = (
      | s |
      s:: Sub new.
      assert: s a equals: 2.
      assert: s superA equals: 1.
    )

    public testClassIdentity = (
      self assert: #Array   equals: (ObjectMirror reflecting: Array new) className.
      self assert: #Integer equals: (ObjectMirror reflecting: 1) className.
      self assert: #Integer equals: (ObjectMirror reflecting: 10000000000) className.
      self assert: #Double  equals: (ObjectMirror reflecting: (1 // 2)) className.
      self assert: #Double  equals: (ObjectMirror reflecting: 0.5) className.
      self assert: #Block1  equals: (ObjectMirror reflecting: [42]) className.
      self assert: #Object  equals: (ObjectMirror reflecting: Object new) className.
      self assert: #Set     equals: (ObjectMirror reflecting: Set new) className.
      self assert: #String  equals: (ObjectMirror reflecting: 'foo') className.
      self assert: #Symbol  equals: (ObjectMirror reflecting: #foo) className.
      self assert: #True    equals: (ObjectMirror reflecting: true) className.
      self assert: #False   equals: (ObjectMirror reflecting: false) className.
      self assert: #Nil     equals: (ObjectMirror reflecting: nil) className.
    )

    public testAccessToInstanceFields = (
      | o |
      o:: ClassC new.
      o setA: 333.
      self assert: 333 equals: o getA.

      o setF: 333.
      self assert: 333 equals: o getF.
    )

    (* TODO adapt
    public testMetaclasses = (
      self assert: nil              is: Object superclass.
      self assert: Integer          is: 1 class.
      self assert: #'Integer class' is: 1 class class name.
      self assert: Metaclass        is: 1 class class class.

      self assert: #'Metaclass class' is: Metaclass class name.
      self assert: Metaclass          is: Metaclass class class.

      self assert: Object          is: 1 class superclass.
      self assert: #'Object class' is: 1 class class superclass name.
      self assert: Class           is: Object class superclass.
      self assert: Metaclass       is: Class class class.
    ) *)


    public testInstanceFields = (
      (* TODO adapt
      self assert: 2 equals: ClassA fields size.
      self assert: 4 equals: ClassB fields size.
      self assert: 6 equals: ClassC fields size.
      *)
    )
  ) : ( TEST_CONTEXT = () )

  public class EqualsTests = TestContext <: Value ()(
    public testEquals = (
      | arr |
      arr:: Array new: 9.
      arr at: 1 put: true.
      arr at: 2 put: false.
      arr at: 3 put: nil.
      arr at: 4 put: 1.
      arr at: 5 put: 1 << 70.
      arr at: 6 put: 5.55555.
      arr at: 7 put: 'foo'.
      arr at: 8 put: #barr.
      (* arr at: 9 put: (ValueArray new: 3 withAll: 1). *)

      1 to: 8 do: [:i |
        1 to: 8 do: [:j |
          i = j
            ifTrue: [ assert: (arr at: i) equals: (arr at: j) ]
            ifFalse: [ deny: (arr at: i) = (arr at: j) ] ] ]
    )
  ) : ( TEST_CONTEXT = () )

  public class ValueTests = TestContext <: Value ()(
    class Mutable new: obj = (
      | public mut ::= obj. |
    )(
      public class Immutable new: obj = (
        | public imm = obj. |
      )() : ( public new = ( ^ self new: 0 ) )
    ) : ( public new = ( ^ self new: 0 ) )

    class Immutable new: obj = Value (
      | public imm = obj. |
    )(
      public class Immutable new: obj = Value (
        | public imm = obj. |
      )() : ( public new = ( ^ self new: 0 ) )
    ) : ( public new = ( ^ self new: 0 ) )

    class Mutable2 new: obj = (
      | public mut ::= obj. |
    )(
      public class NoField = ()()
    )

    class Immutable2 new: obj = Value (
      | public imm = obj. |
    )(
      public class NoField = Value ()()
    )

    class Immutable3 = Value (
      | public imm = 0. |
    )(
      public class NoField = ()()
    )

    class ImmutableObject = ()()
    class ImmutableValue  = Value ()()
    class ImmutableObjectWithValueMixin = Object <: Value ()()

    public testOnlyExplicitValuesAreValues = (
      deny:   (ObjectMirror reflecting: ImmutableObject new) isValue.
      assert: (ObjectMirror reflecting: ImmutableValue  new) isValue description: 'ImmutableValue has explicit superclass Value'.
      assert: (ObjectMirror reflecting: ImmutableObjectWithValueMixin new) isValue description: 'ImmutableObjectWithValueMixin has Value mixin'.
    )

    public testObjWithoutFieldsIsNotValue = (
      | i |
      i:: Immutable3 new.
      deny: (ObjectMirror reflecting: i NoField new) isValue.
    )

    public testImmutableButNotAValueDoesNothing = (
      | m |
      m:: Mutable new: 0.
      shouldnt: [m Immutable new: 0] signal: NotAValue
    )

    public testInitValueWithMutable = (
      | m |
      m:: Mutable new: 0.
      should: [Immutable new: m] signal: NotAValue
    )

    public testIntegersAreValues = (
      assert: (ObjectMirror reflecting:        0) isValue.
      assert: (ObjectMirror reflecting: 1 << 100) isValue.
      assert: (ObjectMirror reflecting:      -66) isValue.
    )

    public testDoublesAreValues = (
      assert: (ObjectMirror reflecting:  0.0) isValue.
      assert: (ObjectMirror reflecting:  2.3) isValue.
      assert: (ObjectMirror reflecting: -1.4) isValue.
    )

    public testBooleansAreValues = (
      assert: (ObjectMirror reflecting: true)  isValue.
      assert: (ObjectMirror reflecting: false) isValue.
    )

    public testNilIsValue = (
      assert: (ObjectMirror reflecting: nil) isValue.
    )

    public testStringsAreValues = (
      assert: (ObjectMirror reflecting: 'asdasd') isValue.
      assert: (ObjectMirror reflecting: 'asdasd' + 'sss') isValue.
    )

    public testSymbolsAreValues = (
      assert: (ObjectMirror reflecting: #fff) isValue.
      assert: (ObjectMirror reflecting: 'asdasd' asSymbol) isValue.
    )

    public testPlainObjectIsNotValue = (
      deny: (ObjectMirror reflecting: Object new) isValue.
    )

    public testValueIsValue = (
      assert: (ObjectMirror reflecting: Value new) isValue.
    )

    public testModuleIsValue = (
      | langTestsModuleClass |
      langTestsModuleClass:: (ObjectMirror reflecting: langTestsModule) classMirror classObject.
      assert: (ObjectMirror reflecting: langTestsModuleClass) isValue.
      assert: (ObjectMirror reflecting: langTestsModule) isValue
    )

    public testClassesAreValuesIffTheirEnclosingObjectIsAValue = (
      (* some kernel classes *)
      | m mm |
      assert: (ObjectMirror reflecting: Object)       isValue description: 'Object'.
      assert: (ObjectMirror reflecting: Array)        isValue description: 'Array'.
      assert: (ObjectMirror reflecting: ObjectMirror) isValue description: 'ObjectMirror'.
      assert: (ObjectMirror reflecting: Set)          isValue description: 'Set'.
      assert: (ObjectMirror reflecting: TestContext)  isValue description: 'TestContext'.

      m:: Mutable new: 0.
      deny: (ObjectMirror reflecting: m Immutable) isValue description: 'm Immutable not a Value'
    )

    public testArraysArentValues = (
      deny: (ObjectMirror reflecting: (Array new: 1)) isValue.
      (* Empty arrays could be values, but aren't, by definition *)
      deny: (ObjectMirror reflecting: (Array new: 0)) isValue.
    )

    public testBlocksArentValues = (
      | var |
      (* Generally, blocks aren't values, because they could have lexical
         scopes that are mutable.
         And until we don't optimize that, let's make them all non-Values. *)
      deny: (ObjectMirror reflecting: [0])       isValue.
      deny: (ObjectMirror reflecting: [:r | r ]) isValue.
      deny: (ObjectMirror reflecting: [var])     isValue.
    )

    public testPairIsntValue = (
      deny: (ObjectMirror reflecting: (kernel Pair withKey: 5 andValue: 4)) isValue.
    )

    public testVectorsArentValues = (
      deny: (ObjectMirror reflecting: kernel Vector new) isValue.
    )

    public testExceptionIsNotAValue = (
      deny: (ObjectMirror reflecting: kernel Exception new) isValue.
    )

    public testOuterScopeMutability = (
      | m mi |
      m:: Mutable new.
      mi:: m Immutable new.

      deny: (ObjectMirror reflecting: m) isValue.
      deny: (ObjectMirror reflecting: mi) isValue.
    )

    public testOuterScopeImmutability = (
      | i ii |
      i::  Immutable new.
      ii:: i Immutable new.

      assert: (ObjectMirror reflecting: i) isValue.
      assert: (ObjectMirror reflecting: ii) isValue.
    )

    public testMutableObjectDeepInImmutableConstruct = (
      | i iii |
      i:: Immutable new.
      should: [i Immutable new: (Mutable new: 0)] signal: NotAValue.
      iii:: i Immutable new: Immutable new.

      assert: (ObjectMirror reflecting: i) isValue.
      assert: (ObjectMirror reflecting: iii) isValue.
    )

    public testInnerNoFieldHandling = (
      | mm mmn  mi min  ii iin |
      mm:: Mutable2 new: (Mutable new: 0).
      mmn:: mm NoField new.
      deny: (ObjectMirror reflecting: mm)  isValue description: 'case mm'.
      deny: (ObjectMirror reflecting: mmn) isValue description: 'case mm'.

      mi:: Mutable2 new: 0.
      min:: mi NoField new.
      deny: (ObjectMirror reflecting: mi)  isValue description: 'case mi'.
      deny: (ObjectMirror reflecting: min) isValue description: 'case min'.

      should: [Immutable2 new: (Mutable new: 0)] signal: NotAValue.

      ii::  Immutable2 new: 0.
      iin:: ii NoField new.
      assert: (ObjectMirror reflecting: ii)  isValue description: 'case ii'.
      assert: (ObjectMirror reflecting: iin) isValue description: 'case iin'.
    )
  ) : ( TEST_CONTEXT = () )

  public class OuterTests = TestContext ()(
    class RadixSort = (
    | private numValues = 3. |
    )(
      public class SortActor = (
      | public outerNumValues = numValues. |
      )()
    )

    public testOuterSendWithManyOuterInstances = (
      | arr |
      arr:: Array new: 100 withAll: [RadixSort new].
      arr do: [:rs |
        assert: rs SortActor new outerNumValues equals: 3
      ]
    )
  ) : ( TEST_CONTEXT = () )

  (* Test Regression with non-local variables *)
  public class NonLocalVarAccess = TestContext ()(

    public testWriteDifferentTypes = (
      | value |
      1 to: 10 do: [:i |
        value:: 0.
        self collection do: [:i | value:: value + i].
        value:: value // 4.
      ].

      assert: value equals: 3.75
    )

    private collection = ( ^ { 7. 8 } )
  ) : ( TEST_CONTEXT = () )

  public class ReadUnwrittenVar = TestContext ()(
    private helper = (
      | v result |
      result:: Array new: 2.
      result at: 1 put: v.
      v:: 1.
      result at: 2 put: v.
      ^ result
    )
    public testReadUnwrittenVars = (
      | result |
      result:: helper.
      self assert: nil equals: (result at: 1).
      self assert:   1 equals: (result at: 2).

      result:: helper.
      self assert: nil equals: (result at: 1).
      self assert:   1 equals: (result at: 2).
    )
  ) : ( TEST_CONTEXT = () )

  public class OverriddingPrimaryFactoryMethods = TestContext ()(
    public class T1 = ()() : (
      public new = ( ^ nil )
    )

    public class T2 fooBar = ()() : (
      public fooBar = ( ^ nil )
    )

    public class T3 bar: arg = ()() : (
      public bar: arg = ( ^ arg )
    )

    public testT1OverrideNew = (
      assert: T1 new is: nil
    )

    public testT2OverrideFooBar = (
      assert: T2 fooBar is: nil
    )

    public testT3OverrideBarWithArg = (
      assert: (T3 bar: nil) is: nil
    )
  ) : ( TEST_CONTEXT = () )

  (* Megamorphic Super send *)
  public class MegamorphicSuperSend = TestContext ()(
    private class A = ()(
      public aNumber = ( ^ 41 )
    )
    private class B = A () (
      public aNumber = ( ^ super aNumber + 1 )
    )
    private class C1 = B ()()
    private class C2 = B ()()
    private class C3 = B ()()
    private class C4 = B ()()
    private class C5 = B ()()
    private class C6 = B ()()
    private class C7 = B ()()
    private class C8 = B ()()
    private class C9 = B ()()

    public testMegamorphicSuper = (
      | a |
      a:: Array new: 9.
      a at: 1 put: C1 new.
      a at: 2 put: C2 new.
      a at: 3 put: C3 new.
      a at: 4 put: C4 new.
      a at: 5 put: C5 new.
      a at: 6 put: C6 new.
      a at: 7 put: C7 new.
      a at: 8 put: C8 new.
      a at: 9 put: C9 new.
      1 to: 7 do: [:i |
        self assert: 42 equals: (a at: i) aNumber ]
    )
  ) : ( TEST_CONTEXT = () )

  public class InitializerForLocalVariables = TestContext ()(
    public testSimpleInitializers = (
      | cnt ::= 0.
        inc = 1. |

      assert: cnt equals: 0.
      assert: inc equals: 1.

      cnt:: cnt + inc.
      cnt:: cnt + inc.

      assert: cnt equals: 2.
      assert: inc equals: 1.
    )

    private myself = ( ^ self )
    private ret: o = ( ^ o )

    public testMoreComplexExpressions = (
      | zero ::= 4 - 8 + 4.
        obj = myself.
        o = ret: obj. |

      assert: zero equals: 0.
      assert: obj  is:  self.

      assert: o is: self.
    )
  ) : ( TEST_CONTEXT = () )

  public class MessageCascades = TestContext ()(
    class Cnt = (| public v ::= 0. |)(
      public inc = ( v:: v + 1 )
    )

    class Setters = (|
      public slot1
      public slot2
    |)(
	    public runCascadeForEffect = (
        self slot1: 23;
             slot2: 42
      )

      public runCascadeForValue = (
        ^ self slot1;
               slot2
      )
    )

    class InlinedScopes = (
    | public if = true ifTrue: [ Cnt new inc; inc; inc ].
      public if2 = [ true ifTrue: [ Cnt new inc; inc; inc ] ] value.
    |)()

    public testCascadeOnFieldRead = (
      | c = Cnt new. |
      assert: c v equals: 0.
      c inc; inc; inc.
      assert: c v equals: 3.
    )

    public testCascadeOnMultipleSends = (
      | c = Cnt new. |
      assert: c v equals: 0.
      c inc inc inc;
        inc;
        inc;
        inc.
      assert: c v equals: 6.
    )

    public testKeywordCascade = (
      | arr = Array new: 3. |

      arr at: 1 put: 2;
          at: 2 put: 3;
          at: 3 put: 4.
      assert: (arr at: 1) equals: 2.
      assert: (arr at: 2) equals: 3.
      assert: (arr at: 3) equals: 4.
    )

    public testSetter = (
      | setter = Setters new. |
      setter runCascadeForEffect.
      assert: setter slot1 equals: 23.
      assert: setter slot2 equals: 42.
      assert: setter runCascadeForValue equals: 42.
    )

    public testCascadeInInlinedBlocks = (
      | i   = InlinedScopes new.
        if  = true ifTrue: [ Cnt new inc; inc; inc ].
        if2 = [ true ifTrue: [ Cnt new inc; inc; inc ] ] value. |
      assert: i if v  equals: 3.
      assert: i if2 v equals: 3.

      assert: if v  equals: 3.
      assert: if2 v equals: 3.

      assert: (true ifTrue: [ Cnt new inc; inc; inc ]) v         equals: 3.
      assert: [ true ifTrue: [ Cnt new inc; inc; inc ] ] value v equals: 3.
    )
  ) : ( TEST_CONTEXT = () )

  public class OperatorSequences = TestContext ()(
    class Op = (
    | public operator
      public operand
    |)(
      public -> op = (
        operator:: #arrowRight.
        operand:: op
      )

      public <- op = (
        operator:: #arrowLeft.
        operand:: op
      )
    )

    public testArrows = (
      | o = Op new. |

      o <- 4.

      assert: #arrowLeft equals: o operator.
      assert: 4          equals: o operand.

      o -> 54.

      assert: #arrowRight equals: o operator.
      assert: 54          equals: o operand.
    )
  ) : ( TEST_CONTEXT = () )
)
