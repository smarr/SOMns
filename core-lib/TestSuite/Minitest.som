class Minitest usingPlatform: platform = Value (
(* Minitest is the unit testing framework of Newspeak.

Users familiar with SUnit should note that Minitest is not an SUnit port or
clone, but rather a complete redesign that revises the core structures and
mechanisms to simplify test definitions and to make use of language facilities
unique to Newspeak.

CORE CLASSES

Most of the classes defined by this module are internal to its implementation
and are not intended to be subclassed or directly instantiated by the framework
users. SUnit users, note: this includes the class named TestCase! The only
class the typical test writer imports and sublcasses is TestContext. A
developer working on IDE tools may also need access to TestCatalog and Tester.

BASIC TESTS

Defining tests begins with defining the test module--a top-level class to hold
everything else. As the arguments, the factory of a test module typically takes
an instance of the Newspeak platform, an instance of the Minitest module, and
the factory or factories that create the tested object(s).

    class ListTesting usingPlatform: platform minitest: minitest listClass: listClass = (
    |
        private TestContext = minitest TestContext.
        private List = listClass.
    |
    ...

The actual tests are defined as methods of a test context, a subclass of
TestContext nested inside the test module.

    (* nested inside MyCollectionsTest *)
    class ListTests = TestContext (
         | list = List new. |
    ) (
        testAddition = (
            list add: 1.
            assert: (list includes: 1)
        )
        testRemoval = (
            list add: 1; remove: 1.
            deny: (list includes: 1)
        )
    ) : (
        TEST_CONTEXT = ()
    )

This test context defines two test methods, recognized as such because they
begin with the word 'test'. To run each of those, the framework will create a
fresh instance of the ListTests class and send it the message required to
invoke the method. A separate instance is created to run each of the test
methods in a test context, so the List used by testRemoval is different from
the one used by testAddition.

Note the empty class-side method named TEST_CONTEXT. This is what makes the
test framework recognize this class as a test context and scan it for test
methods. Eventually, when Newspeak supports it, class metadata will be used
instead to mark classes as test contexts.

This important point is worth reiterating. A class is a test context if and
only if it contains a class-side method named TEST_CONTEXT. Inheriting from
TestContext by itself does NOT make a class a test context, it only provides it
with behavior such as the various #assert:... messages useful in test methods.
Being a test context means that the class is scanned for test methods by the
framework, and instantiated to run each of those methods.

SHARED STATE

Each test method of a test context runs within a context instance created and
initialized specifically to run that method. In cases when tests need access to
information which is too expensive to create for each individual test, such as
a group of Newspeak modules or a database session, it is possible to share the
information between the tests. To do that, we introduce a _shared state class_
between the module and the test context, as in the following nesting diagram:

    CompilerTests (top level)
        CompilerHolder (holds onto a compiler instance; not marked a test context)
            StatementsTests (a test context)

In this example, StatementsTests is a test context class with a number of test
methods, all of which require a compiler instance to test. Assuming that
creating a compiler is expensive, we instead nest the test context in a class
called CompilerHolder, defined something like

    class CompilerHolder = (
        | compiler = Compiler configuredInAParticularWay.
        ...

We assume that 'Compiler' is a name appropriately bound by the CompilerTests
module. The CompilerHolder class is not marked as a test context, and does not
require any particular behavior other than supporting the #new factory message.

The CompilerHolder class is instantiated only once before running all the tests
of the CompilerTests module. The StatementsTests class of the CompilerHolder
instance is repeatedly instantiated for each test it defines. Each instance of
StatementsTests sees the 'compiler' slot of its enclosing object, which allows
all of the tests defined in StatementsTests to use the same compiler instance.

More precisely, the behavior in the general case is this. To detect and run
tests, the test framework recursively traverses class declarations starting
from that of the top-level module and stopping at classes marked as test
contexts. Classes nested inside a test context, if any, are ignored. In the
resulting tree, the framework considers three distinct parts. The root of the
tree is the class of the top-level test module instance (which already exists).
The leaves of the tree are test context classes. Any nodes between the root and
the leaves are shared state classes. Instances of shared state classes are
created once before running the entire batch of tests defined in all test
contexts of the module. Instances of test contexts are created multiple times,
once for each test method of a context.
   
RUNNING IT: TEST CONFIGURATIONS     

Like any Newspeak module, a test module expects the platform and other
necessary information to be provided at the time an instance is created. That
information includes the factory such as a class object, that will create the
actual instances to test. At different times it may make sense to instantiate a
module with different sets of parameters, for example to test different
versions of a class or different classes implementing the same interface. Any
such specific configuration of a test module is captured as a _test
configuration_ class.

A test configuration is defined as a top-level class, similar to an application
configuration. [TODO: describe the factory method once we settle on the final
selector to use.] Like an application configuration, a test configuration is
supplied with an ideNamespace that provides access to all top-level modules
currently in the IDE. Also like an application configuration, a test
configuration is expected to capture in its private slots ('import') references
to any modules it will eventually instantiate. For example, a configuration for
the ListTesting module above may look something like

    class ListTestingConfiguration using: ideNamespace = (
    |
        private ListTesting = ideNamepace ListTesting.
        private LinkedList = ideNamespace Collections LinkedList.
    |
    ...

A configuration class should implement one instance-side method named
testModulesUsingPlatform:minitest:. The method should instantiate and return a
collection of configured test modules (in our example, only one).

    testModulesUsingPlatform: platform minitest: minitest = (
        ^{ListTesting usingPlatform: platform minitest: minitest listClass: LinkedList}

If the Collections module includes other implementors of the List interface,
the example can be extended to use multiple instances of ListTesting to test
other implementors. For example, provided there is a collection class named
ArrayList in Collections and it has been 'imported' into a slot of
ListTestingConfiguration, we could rewrite the method to test both
implementations:

    testModulesUsingPlatform: platform minitest: minitest = (
        ^{
            ListTesting usingPlatform: platform minitest: minitest listClass: LinkedList.
            ListTesting usingPlatform: platform minitest: minitest listClass: ArrayList.
        }

Alternatively, we may define a separate test configuration to test ArrayList.

REEDUCATION FOR SUNIT USERS

The following is a comparison of the key differences between the traditional
SUnit API and the goodthinkful way of doing the same thing.

TestCase vs TestContext

In SUnit, tests are defined as methods of a subclass of TestCase, while in
Minitest TestContext takes it place. This is not a simple renaming. SUnit's
TestCase suffers from a split personality. It is both a test fixture, which is
a particular configuration of tested object on which a set of tests can be
performed, and a command to run one of those tests. It is also another thing
that we will eventually get to. The author believes this confusion, repeated in
SUnit clones for other languages, leads to increased complexity and
inconsistencies in terms and concepts (for example, by defining 'a TestCase' in
SUnit, we in fact define many test cases). In contrast, Minitest assigns these
responsibilities to separate classes, which are TestContext and TestCase. A
test context defines a configuration of tested objects and the actual tests,
while a TestCase is a command object for running a particular test of a test
context. Minitests's TestCase is internal to the framework implementation and
not normally exposed to the framework users.

The role of TestCase/TestContext as a superclass

Because of the merging of two independent concepts in SUnit's TestCase, the
TestCase class in SUnit must be a superclass of a user-defined set of tests. In
Minitest, a test context is recognized as a class marked as such (currently
with a marker method, eventually in the class's metadata). A test context class
usually inherits from TestContext, however that is not required by the
framework. The only reason for this inheritance is to allow the use in test
methods of the various #assert: methods defined by TestContext. A test context
class is free not to inherit from TestContext, as long as it has some other way
to signal the TestFailureException in case of a test failure. (This is why this
text usually refers to a Minitest test context as 'a test context' rather than
'a TestContext').

The #setUp method vs instance initializer

In SUnit, any necessary initialization of a TestCase subclass is performed by
the #setUp method. In Minitest, instances of text contexts are initialized
(naturally) by their initializers. Again, the reason for this difference is the
split personality of SUnit's TestCase, leading to what in essence are multiple
initialization schemes for those personalities.

The #tearDown method vs the #cleanUp method

A test context (or a shared class instance) can define any necessary clean up
behavior as a method named #cleanUp. A similar method in SUnit is named
#tearDown. Minitest makes this API change because of the necessary change to
the other half of lifecycle management (#setUp vs instance initializer), and
also because the author believes cleanUp is a more natural name, which is now
free of danger of being confused with setUp.

TestResources vs shared state classes

SUnit provides test resources as a mechanism to share expensive to create
objects between a batch of test cases. Minitest does that using enclosing
shared state classes. There is no dedicated TestResource class in Minitest
because the framework expects nothing from the shared state class API other
than the ability to create an instance using #new. At the same time, the
framework takes care of creating and cleaning up their instances, so the test
programmer is free from concerns of maintaining resource instances and managing
their lifecycle. Shared state is naturally accessible to all tests that require
it a part of the lexical scope. Lexical containment also naturally specifies
which tests require which resources, without the fragility and obscurity of the
various #resources methods of SUnit.

TestCases vs test configurations

A TestCase subclass in SUnit is a concrete runnable test artifact (in the sense
that we can select one in a UI tool and run its tests). In Minitest, a test
module with any tests it contains is only an abstract declaration. It needs a
test configuration to instantiate it with a specific set of parameters. Test
configuration is the third personality of SUnit's TestCase separated into an
independent class in Minitest. More about this in the next section.

TestCase subclassing vs parameterizable tests

SUnit supports further subclassing of TestCase subclasses. For example, tests
for a widget library can define, say, WidgetTestCase with LabelTestCase and
ButtonTestCase as subclasses. WidgetTestCase is an abstract class defining
tests of the API common to all widgets, while ButtonTestCase specializes it
with tests specific to buttons. It also defines the concrete class tests
inherited from WidgetTestCase apply to. Running ButtonTestCase is supposed to
run both the tests defined locally as well as those inherited from
WidgetTestCase.

Minitest does not--and more importantly, does not need to--support test context
inheritance to accomplish what is described above. More precisely, any class in
a test module is free to inherit from any other class, be it a test context or
not. However, if a test context class inherits from another test context class,
only test methods defined locally in that particular class are recognized and
executed by the framework. This is not a limitation, but rather the test
parameterization story made straight. Let's begin with an example of the
Minitest way of organizing the tests described above.

We define 3 test modules with the following factory signatures:

    WidgetTesting usingPlatform: platform minitest: minitest widgetClass: aClass
    LabelTesting usingPlatform: platform minitest: minitest labelClass: aClass
    ButtonTesting usingPlatform: platform minitest: minitest buttonClass: aClass

Each would have at least one test context class with all the appropriate tests.
We also define two configuration classes, LabelTestConfiguration and
ButtonTestConfiguration. As an example, LabelTestConfiguration would import the
Label class from the widget library and define this method:

    testModulesUsingPlatform: platform minitest: minitest = (
        ^{
            WidgetTesting usingPlatform: platform minitest: minitest widgetClass: Label.
            LabelTesting usingPlatform: platform minitest: minitest labelClass: Label.
        }

Here is why this approach is cleaner. Remember the point from the discussion of
TestCases and test configurations above. The third overloaded responsibility of
TestCase in SUnit is test configuration. A LabelTestCase needs to inherit from
WidgetTestCase so that the tests of the Widget interface defined in that
abstract class can be applied to a concrete implementation (Label). The
Minitest example uses the fact test definition is parameterizable by test
configuration to organize the code around this pattern:

1. A module does not hardcode the actual implementation class it tests, instead
   expecting a _factory_ (in this case a class metaobject) that can manufacture
   instances to test on request.

2. All tests in a module are written to test a particular _interface_.
   Different interfaces should be tested by different modules.

3. A test configuration is what chooses a particular _implementation class_ to
   test. The configuration creates test modules for all interfaces the class
   implements, parameterized with the class being tested.

This pattern is the recommended way to organize tests using Minitest. You can
see that the ListTesting and ListTestingConfiguration follow a similar idea.
ListTesting defines tests of the List interface, while the configuration
applies it to two concrete implementation classes.


LICENSE

Copyright (c) 2010 Vassili Bykov
Copyright (c) 2012 Cadence Design Systems, Inc.

Licensed under the MIT license:

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the ''Software''), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE. *)
|
  private Exception      = platform kernel Exception.

  private Dictionary         = platform collections Dictionary.
  private IdentityDictionary = platform collections IdentityDictionary.
  private Vector             = platform kernel Vector.
  private Array              = platform kernel Array.
  private IdentitySet        = platform collections IdentitySet.
  
  private ObjectMirror = platform mirrors ObjectMirror.
  private actors       = platform actors.
|)(
  class TestCase env: testEnvironment selector: selector = (
    (* Represents a particular test (a method with the selector that begins with
       'test') in a text context. This class, unlike SUnit's class by the same 
       name, is internal to the framework and is not intended to be subclassed
       or instantiated by framework users. See TestContext.

       An instance holds onto a test environment (which indirectly identifies
       the test context class) and a selector within the class. While a test
       is running, an instance also holds onto the test context's instance
       created to run the test. That instance is created prior to running the
       test. If the test is successful, the instance is immediately discarded.
       In case of a failure or an error, the instance is retained so that its
       state can be examined. *)
    |
      public environment = testEnvironment.
      public selector    = selector.
      testContextInstance
    |
  ) (
    public isAsync = ( ^ false )
  
    public runUsing: tester = (
      ^ [self runUnsafeUsing: tester]
          on: Exception
          do: [:ex | ^testContextInstance 
            ifNil: [TestError case: self exception: ex] 
            ifNotNil: [:it | it createErrorResultFor: self exception: ex]]
    )

    public runToDebugFailureUsing: tester = (
      instantiateTestContextUsing: tester.
      [sendTestMessage]
        ensure: [cleanUp]
    )

    public cleanUp = (
      (* Clean up and forget the test context instance. This method runs within
         an exception handler established by the runUsing: method, so any errors
         in test context instance cleanup are ok. *)
      testContextInstance isNil ifFalse:
        [testContextInstance cleanUp.
        testContextInstance := nil]
    )

    instantiateTestContextUsing: tester = (
      testContextInstance := environment createInstanceIn: (tester instanceFor: environment parent)
    )
    
    sendTestMessage = (
      ^ (ObjectMirror reflecting: testContextInstance) perform: selector
    )

    public runUnsafeUsing: tester = (
      | testSuccess |
      instantiateTestContextUsing: tester.
      [sendTestMessage.
      (* At this point the test has been successful, so create the TestSuccess before it is removed. *)
      testSuccess := testContextInstance createSuccessResultFor: self.
      (* Clean up immediately after a successful test. This makes the test context instance
      immediately garbage-collectable, which is an important property for large test suites. *)
      cleanUp]
        on: TestFailureException
        do: [:ex |
               (* testContextInstance should never be nil at this point, but just in case. *)
               ^ testContextInstance 
                  ifNil: [TestFailure case: self description: ex messageText]
                  ifNotNil: [:it | it createFailureResultFor: self description: ex messageText]].
      ^ testSuccess
    )
    
    public asString = (
      ^ 'TestCase(' + selector asString + ')'
    )
  ) : (
    public environment: testEnvironment selector: selector = (
      ^ ((selector beginsWith: 'testAsync')
          ifTrue: [ AsyncTestCase ] ifFalse: [ TestCase ])
            env: testEnvironment selector: selector
    )
  )
  
  class AsyncTestCase env: testEnvironment selector: selector
    = TestCase env: testEnvironment selector: selector ()(
    public isAsync = ( ^ true )
    
    public runUsing: tester = (
      | promisePair |
      instantiateTestContextUsing: tester.
      promisePair := actors createPromisePair.
      [[| promise testSuccess |
          promise := sendTestMessage.
          promise whenResolved: [:r |
            (* At this point the test has been successful, so create the TestSuccess before it is removed. *)
            testSuccess := testContextInstance createSuccessResultFor: self.
            (* Clean up immediately after a successful test. This makes the test context instance
            immediately garbage-collectable, which is an important property for large test suites. *)
            cleanUp.
            promisePair resolve: testSuccess ].
          promise on: TestFailureException do: [:ex |
            promisePair resolve: (testContextInstance 
              ifNil:    [ TestFailure case: self description: ex messageText]
              ifNotNil: [:it | it createFailureResultFor: self description: ex messageText])].
          promise on: Exception do: [:ex |
            promisePair resolve: (testContextInstance 
              ifNil:    [ TestError case: self exception: ex ]
              ifNotNil: [:it | it createErrorResultFor: self exception: ex ])]
        ] on: TestFailureException
          do: [:ex |
            (* testContextInstance should never be nil at this point, but just in case. *)
            promisePair resolve: (testContextInstance 
              ifNil:    [ TestFailure case: self description: ex messageText ]
              ifNotNil: [:it | it createFailureResultFor: self description: ex messageText ])]
      ] on: Exception
        do: [:ex | 
          promisePair resolve: (testContextInstance 
            ifNil:    [ TestError case: self exception: ex ]
            ifNotNil: [:it | it createErrorResultFor: self exception: ex ])].
      ^ promisePair promise
    )

    public asString = (
      ^ 'Async' + super asString
    )
  )

  public class TestCatalog forModule: testModule select: testClass test: testCaseSelector = (
    (* A catalog of test suites defined by a given test module instance. A 
       catalog is created using the primary forModule: factory method. Each of
       test context classes of the module produces a TestSuite that lists all
       test methods in the class. The catalog can report the names of all test
       context classes, and return a TestSuite corresponding to each class. It
       can also return a TestSuite with the union of all the class-level
       TestSuites. *)
    | testModule = testModule.
      testsByContextName = Dictionary new.
      testClass = testClass. (* if set, filter out this class *)
      testCaseSelector = testCaseSelector. (* if set, only run this test method *)
    |
      Initializer new populate
  ) (
    class Initializer = (
      (* An initializer populates the enclosing catalog with content extracted
         from the test module. This class is internal to the TestCatalog
         implementation. *)
    )(
      'accessing'
      public populate = (
        (* Populate the testsByContextName dictionary of the enclosing 
           TestCatalog instance with information extracted from the module. *)
        | moduleMirror moduleEnvironment |
        moduleEnvironment := TopLevelTestEnvironment module: testModule.
        moduleMirror := (ObjectMirror reflecting: testModule) classMirror.
        
        testClass
          ifNil:    [populateWithAllIn: moduleEnvironment using: moduleMirror]
          ifNotNil: [populateSelected:  moduleEnvironment using: moduleMirror].
        
        moduleEnvironment withAllNestedEnvironmentsDo: [:each |
            each hasTestCases ifTrue:
              [testsByContextName at: each name put: each testSuite]]
      )
      
      populateWithAllIn: moduleEnvironment using: moduleMirror = (
        moduleMirror classDefinition 
          nestedClassDefinitions do: [:each |
            examineClass: each under: moduleEnvironment].
      )
      
      populateSelected: moduleEnvironment using: moduleMirror = (
        moduleMirror classDefinition 
          nestedClassDefinitions do: [:each |
            each name = testClass ifTrue: [
              examineClass: each under: moduleEnvironment]]
      )

      examineClass: mirror under: parentEnvironment = (
        (* Examine the given class. If it is a test context, create a test suite
           listing its test cases and add it to the catalog. *)
        | thisEnvironment |
        thisEnvironment := TestEnvironment parent: parentEnvironment classDeclarationMirror: mirror.

        (isTestContext: mirror) ifTrue: [
          thisEnvironment testCases: (testCasesIn: mirror environment: thisEnvironment).
          parentEnvironment addNestedEnvironment: thisEnvironment.
          (* Nested test contexts do not appear to be useful, so once a test
             context is found we do not look inside it. The framework's own
             tests rely on this. *)
           ^ self ].

        mirror classDefinition nestedClassDefinitions do: [:each |
          examineClass: each under: thisEnvironment].
          
        (* If after all the examination thisEnvironment ends up with no test
           cases, or child environments containing test cases, its class need
           not to be instantiated at runtime. In that case we can forget it
           right here - no need to add it to the parent. *)

        thisEnvironment hasTestCasesTransitively ifTrue: [
          parentEnvironment addNestedEnvironment: thisEnvironment]
      )

      'parameters'
      testContextMarkerSelector = (
        (* A class that has a class-side method with this selector is recognized
           by the Initializer as a test context class. (The class's superclass
           chain is unimportant--test contexts inherit from TestContext only in
           order to get testing behavior such as the #assert: method). *)
        ^ #TEST_CONTEXT
      )

      private isTestContext: mirror = (
        ^ mirror hasFactoryMethod: testContextMarkerSelector
      )

      private isTestMethod: methodMirror = (
        | selector isTest |
        selector := methodMirror name.
        
        isTest := (selector beginsWith: 'test') and: [(selector includes: ':') not].
        testCaseSelector ifNil: [ ^ isTest ].
        ^ (isTest and: [selector = testCaseSelector])
      )

      private testCasesIn: classMirror environment: environment = (
        (* Return a collection of TestCases describing test methods in the given class. *)
        | testCases |
        testCases := Vector new.
        classMirror methods do:
          [:each |
          (isTestMethod: each) ifTrue:
            [testCases append: 
              (TestCase environment: environment selector: each name)]].
        ^testCases
      )
    )

    'accessing'
    public allTests = (
      (* Returns a test suite containing all test cases defined in all test
         context classes of the catalogued module. *)
      | allTestCases |
      allTestCases := Vector new: testsByContextName size + 1 * 20.
      testsByContextName do: [:each | allTestCases appendAll: each testCases].
      ^TestSuite testCases: allTestCases
    )

    public testSuiteNamed: key = (
      (* Returns a test suite containing all test cases of the given class. *)
      ^testsByContextName at: key
    )

    public testSuiteNames = (
      (* Returns the (short) names of test context classes of the module. *)
      ^testsByContextName keys
    )
  ) : (
    public forModule: module = (
      ^ forModule: module select: nil test: nil
    )
    
    public forModule: module select: testClass = (
      ^ forModule: module select: testClass test: nil
    )
  )

  public class TestContext = (
    (* An object for defining and running individual tests. In this respect, it
       is the same thing as the TestCase class of the traditional SUnit
       framework. Unlike SUnit's TestCase, an instance does not double as a
       command for running a particular test method.

       This class provides the behavior useful for running tests, such as the
       various #assert: methods inheritable by the user's TestContext
       subclasses. Inheriting that behavior is the only real reason to inherit
       from TestContext. The test framework does NOT recognize the user's test
       contexts on the basis of their inheritance. Instead, each class to be
       treated as a test context should be marked as such. Currently, it is
       done with a class-side marker method named TEST_CONTEXT. In the future,
       marker methods will be superseded by proper class metadata.

       An instance is initialized by its 'natural' initializer. If any special
       cleanup behavior is required after running a test, a subclass may
       reimplement the #cleanUp method to define it. *)
  ) (
    'accessing'
    public cleanUp = (
      (* Sent after a successful completion of a test, to clean up if simple
         garbage collection at some point in the future is not enough (which it
         normally should be). If a test completes abnormally, with either a
         failure or an error, the test context is retained by the test case
         which in turn is retained by the test result. In this case, the
         message is not sent until a later time when the test results are
         discarded. *)
    )

    public createErrorResultFor: testCase exception: ex = (
      ^TestError case: testCase exception: ex
    )
  
    public createFailureResultFor: testCase description: description = (
      ^TestFailure case: testCase description: description
    )

    public createSuccessResultFor: testCase = (
      ^TestSuccess case: testCase
    )

    private failWithMessage: messageText = (
      TestFailureException signal: messageText
    )

    'testing'
    assert: aBlockOrValue = (
      assert: aBlockOrValue description: 'Assertion failed'
    )

    assert: aBlockOrValue description: messageText = (
      assert: aBlockOrValue descriptionBlock: [messageText]
    )

    assert: aBlockOrValue descriptionBlock: messageBlock = (
      aBlockOrValue value ifFalse: [
        failWithMessage: messageBlock value.
      ]
    )

    assert: anObject is: expectedObject = (
      assert: anObject == expectedObject descriptionBlock: [
        'Object Equality assertion failed; expected: ' + expectedObject asString +
        ', was: ' + anObject asString
      ]
    )

    assert: anObject equals: expectedObject = (
      (* Succeed if anObject = anotherObject. Preferable to a simple
         'assert: [a = b]' in a test method because in case of a failure the 
         values compared are available for inspection as this method's
         arguments. *)
      assert: anObject = expectedObject descriptionBlock: [
        'Equality assertion failed; expected: ' + expectedObject asString +
        ', was: ' + anObject asString
      ]
    )

    assert: anObject equals: anotherObject description: messageText = (
      (* Succeed if anObject = anotherObject. Preferable to a simple
         'assert: [a = b]' in a test method because in case of a failure the
         values compared are available for inspection as this method's
         arguments. *)
      assert: anObject = anotherObject description: messageText
    )

    assert: anObject equals: anotherObject descriptionBlock: messageBlock = (
      (* Succeed if anObject = anotherObject. Preferable to a simple
         'assert: [a = b]' in a test method because in case of a failure the
         values compared are available for inspection as this method's
         arguments. *)
      assert: anObject = anotherObject descriptionBlock: messageBlock
    )

    deny: aBlockOrBoolean = (
      deny: aBlockOrBoolean description: 'Denial failed'
    )

    deny: aBlockOrBoolean description: messageText = (
      deny: aBlockOrBoolean descriptionBlock: [messageText]
    )

    deny: aBlockOrBoolean descriptionBlock: messageBlock = (
      assert: aBlockOrBoolean value not descriptionBlock: messageBlock
    )

    should: aBlock signal: anException = (
      should: aBlock signal: anException description: 'Expected exception not signaled'
    )

    should: aBlock signal: anException description: failureMessage = (
      should: aBlock signal: anException descriptionBlock: [failureMessage]
    )

    should: aBlock signal: anException descriptionBlock: descriptionBlock = (
      [aBlock value. (* should not return if successful *)
      failWithMessage: descriptionBlock value]
        on: anException
        do: [:ex | ]
    )

    should: aBlock takeLongerThan: aDuration = (
      asYetUnimplemented
    )

    shouldnt: aBlock signal: anException = (
      shouldnt: aBlock signal: anException description: 'Exception signalled'
    )

    shouldnt: aBlock signal: anException description: failureMessage = (
      shouldnt: aBlock signal: anException descriptionBlock: [failureMessage]
    )

    shouldnt: aBlock signal: anException descriptionBlock: descriptionBlock = (
      [aBlock value]
        on: anException
        do: [:ex | failWithMessage: descriptionBlock value]
    )

    shouldnt: aBlock takeLongerThan: aDuration = (
      asYetUnimplemented
    )
  )
  
  public class AsyncTestContext = TestContext <: Value ()(
    assert: promise resolvedWith: expectedResolution = (
      (* TODO: add timeout support *)
      ^ promise
          whenResolved: [:actualResolution |
            assert: actualResolution equals: expectedResolution ]
          onError: [:actualResolution |
            failWithMessage: 'Promise broken with error: ' + actualResolution asString ]
    )
  
    assert: promise resolvedWithObject: expectedResolution = (
      (* TODO: add timeout support *)
      ^ promise
          whenResolved: [:actualResolution |
            assert: actualResolution is: expectedResolution ]
          onError: [:actualResolution |
            failWithMessage: 'Promise broken with error: ' + actualResolution asString ]
    )

    assert: promise erroredWith: expectedErrorClass = (
      | state actualResolution |
      state := #unresolved.

      (withTimeout: promise inMSecs: 300)
        whenResolved: [:r | state := #resolved. actualResolution := r ]
        catch:        [:e | state := #error.    actualResolution := e ].

      state = #resolved
        ifTrue: [ ^ failWithMessage: 'Promise resolved with: ', actualResolution printString ].
      state = #error
        ifTrue: [ ^ assert: actualResolution class equals: expectedErrorClass ].
      failWithMessage: 'Invalid state blocking on a promise: ', state.
    )
  )

  class TestEnvironment parent: parent classDeclarationMirror: mirror = (
    (* Describes a class nested inside a test module. The class can be either a
       test context or a parent (direct or indirect) of at least one test
       context. Environments form a tree, with those that represent test
       contexts being the leaves. Environment are used by the framework to
       orchestrate the instantiation of their classes when running tests.

       An instance holds onto the parent and a collection of child
       environments. The class accessor name is the selector of a message that
       can be sent to a class metaobject corresponding to the parent
       environment to obtain a class metaobject corresponding to this
       environment. For an environment representing a test context, testCases
       holds a collection (not a real TestSuite) of TestCases defined in the
       test context. *)
    |
      public parent = parent.
      nestedEnvironments = Vector new.
      public testCases ::= Vector new.
      public classDeclarationMirror = mirror.
    |
  ) (
    'accessing'
    public addNestedEnvironment: environment = (
      nestedEnvironments append: environment
    )

    classIn: parentObject = (
      (* Returns a class metaobject represented by this environment specific
         for the given instance of the class corresponding to this environment's
         parent. *)
      ^ (ObjectMirror reflecting: parentObject) perform: classAccessorName
    )

    public createInstanceIn: parentObject = (
      (* Creates and returns an instance of the class represented by this environment. *)
      ^ (classIn: parentObject) new
    )

    public name = (
      ^classAccessorName
    )

    classAccessorName = (
      (* The class accessor name is the selector of a message that can be sent
         to a class metaobject corresponding to the parent environment to obtain
         a class metaobject corresponding to this environment. *)
      ^ classDeclarationMirror name
    )

    public testSuite = (
      ^TestSuite testCases: testCases
    )

    'enumerating'
    public parentEnvironmentsDo: aBlock = (
      (* Evaluate a one-argument block with direct and indirect parents of this 
         environment, starting with the direct one and proceeding up to the top
         level. *)
      parent withAllParentEnvironmentsDo: aBlock
    )

    public withAllNestedEnvironmentsDo: aBlock = (
      (* Evaluate aBlock with the receiver and all members of the transitive
         closure of its nested environments, in preorder. *)
      aBlock value: self.
      nestedEnvironments do: [:each | each withAllNestedEnvironmentsDo: aBlock]
    )

    public withAllParentEnvironmentsDo: aBlock = (
      (* Evaluate a one-argument block with the receiver and all environment in
         its parent chain all the way up to the top level, beginning with the
         receiver. *)
      aBlock value: self.
      parent withAllParentEnvironmentsDo: aBlock
    )

    'testing'
    public hasTestCases = (
      (* True if the class represented by this environment defines any test methods. *)
      ^testCases isEmpty not
    )

    public hasTestCasesTransitively = (
      (* True if either the class represented by this environment or any of its
         nested classes define any test methods. *)
      ^ hasTestCases or: [nestedEnvironments anySatisfy: [:some | some hasTestCasesTransitively ]]
    )

    public isRoot = (
      (* True if this is a top-level environment representing the entire test
         module. *)
      ^ false
    )
  )

  public class TestError case: testCase exception: exception = TestResult case: testCase (
    (* Represents a test case that didn't complete because an error was signaled
       and not handled while running the test case. The instance holds onto the
       exception instance representing the error. *)
    | public exception ::= exception. |
  ) (
    public description = (
      ^ exception asString
    )
    'testing'
    public isError = (
      ^ true
    )
  )

  public class TestFailure case: testCase description: text = TestResult case: testCase (
    (* Represents a failed assertion in a test case. *)
    | public description ::= text. |
  ) (
    'testing'
    public isFailure = (
      ^ true
    )
  )

  class TestFailureException signal: msg = Exception (
    (* An exception thrown when an assertion fails inside a test.
       The description of the failure is the exception's message text. *)
    | public messageText = msg. |
    self signal.
  ) ()

  class TestResult case: testCase = (
    (* The result of running a TestCase. An abstract class. *)
    | public testCase ::= testCase. |
  ) (
    'accessing'
    public cleanUp = (
      testCase cleanUp
    )

    'testing'
    public isError = (
      ^false
    )

    public isFailure = (
      ^false
    )

    public isSuccess = (
      ^false
    )
  )

  class TestSuccess case: testCase = TestResult case: testCase (
    (* Represents a successful run of a test case. *)
  ) (
    'testing'
    public isSuccess = (
      ^true
    )
  )

  class TestSuite testCases: testCases = (
    (* A TestSuite is a collection of TestCases. TestSuites are usually obtained 
       from a TestCatalog created on an instance of a test module. *)
    | private testCases_slot = testCases. |
  ) (
    'accessing'
    + another = (
      (* Returns a new TestSuite that contains TestCases of the receiver and the argument. *)
      ^TestSuite testCases: testCases, another testCases
    )

    modules = (
      (* Returns a collection of test module instances that contain test cases of the suite. *)
      | result |
      result := IdentitySet new.
      testCases do: [:each | result add: each module].
      ^result
    )

    public size = (
      (* Returns the number of test cases in the suite. *)
      ^testCases size
    )

    public testCases = (
      (* Returns a collection of test cases of the receiver. *)
      ^testCases_slot
    )

    public ++ another = (
      (* Returns a new TestSuite that contains TestCases of the receiver and the argument. *)
      ^TestSuite testCases: testCases, another testCases
    )
  )

  public class Tester testSuite: suite = (
    (* A tool for executing TestCases. TestCases are supplied to it in the form
       of a TestSuite. An instance is single-use only. First it is created
       using the testSuite: primary factory method. Then the tests are
       executed, either by sending the #runAll message, or by reproducing the
       steps defined by #runAll in an external tool. Finally, the results can
       be retrieved from the 'errors', 'failures' and 'successes' slots. *)
    |
      public errors
      public failures
      public successes
      
      private testSuite_ = suite.
      private testCaseStream
      private testsPerformed
      private instanceManager = TestContextManager new.
    |
  ) (
    class TestContextManager = (
      (* Creates and keeps track of instances of shared state classes for a test run.
      Shared state classes are classes nested inside a test module that in turn
      contain other shared state classes and/or test context classes. In other words,
      they are the classes that are neither the root nor the leaves of the class
      nesting tree. Within this class, instances of these classes are referred to as
      'core instances'. *)
      | instancesByEnvironment ::= IdentityDictionary new. |
    ) (
      'accessing'
      public cleanUpCoreInstances = (
        (* Send the #cleanUp message to all core instances able to understand that message. *)
        instancesByEnvironment do:
          [:each |
          (understandsCleanUp: each) ifTrue: [each cleanUp]].
        instancesByEnvironment := IdentityDictionary new.
      )

      public createCoreInstances = (
        (* Create instances of all shared state classes, which are the classes that are
           not test contexts themselves but rather contain test contexts
           directly or indirectly. Such classes are instantiated once before
           running a suite of tests and cleaned up afterwards. *)
        coreEnvironments do:
          [:each |
          ensureInstanceFor: each]
      )

      public createCoreInstancesFor: testCase = (
        (* Create instances of shared state classes required to run the argument
           testCase. See #createCoreInstances. *)
        (coreEnvironmentsFor: testCase) do:
          [:each |
          ensureInstanceFor: each]
      )

      public ensureInstanceFor: environment = (
        (* Return an instance of the class represented by the argument, creating one if necessary. *)
        environment isRoot ifTrue: [^environment moduleInstance].
        ^instancesByEnvironment at: environment ifAbsent:
          [| instance |
          instance := environment createInstanceIn: (ensureInstanceFor: environment parent).
          instancesByEnvironment at: environment put: instance.
          instance]
      )

      'private'
      coreEnvironments = (
      (* The core of the environment tree are the environments between the roots of
      the class tree and its fringe. They have to be instantiated once before running
      the suite and cleaned up after. *)
        | result |
        result := IdentitySet new.
        testSuite testCases do:
          [:each |
          each environment parentEnvironmentsDo:
            [:eachParent |
            eachParent isRoot ifFalse: [result add: eachParent]]].
        ^result
      )

      coreEnvironmentsFor: testCase = (
        | result |
        result := Vector new.
        testCase environment parentEnvironmentsDo:
          [:each |
          each isRoot ifFalse: [result add: each]].
        ^result
      )

      understandsCleanUp: object = (
        (* Answer true if the object understands the #cleanUp message. *)
        | mirror |
        mirror := (ObjectMirror reflecting: object) classMirror.
        ^mirror canUnderstand: #cleanUp
      )
    )

    'accessing'
    public atEnd = (
      (* Returns true if all test cases in the test suite have been executed. *)
      ^testCaseStream atEnd
    )
    public cleanUp = (
      (* This message should be sent to the tester once at some point after
         finishing running the tests. This will cause the tester to send the
         #cleanUp message to all instances of shared state classes created to
         run the tests. Sending this message is not essential to the test
         framework functionality, but without sending it the cleanup logic of
         shared state classes will not be called. However, an IDE tool may
         choose to delay sending this message in case there are tests failures
         or errors, so that the shared state can be examined by the user. *)
      instanceManager cleanUpCoreInstances.
    )

    public cleanUpResults = (
      (* This message causes the #cleanUp message to be sent to all test results,
         which in turn clean ups their associated test cases, cleaning up and
         making garbage-collectable any test context instances they may still
         be holding onto. *)
      successes do: [:each | each cleanUp].
      errors do: [:each | each cleanUp].
      failures do: [:each | each cleanUp]
    )

    public completedRatio = (
      (* Return a number between 0 and 1 indicating the ratio of tests in the
         suite completed so far. *)
      | testCount |
      testCount := testSuite size.
      ^testCount = 0
        ifTrue: [1.0]
        ifFalse: [testsPerformed asFloat / testCount]
    )

    public prepare = (
      (* This message must be sent to the tester once prior to running any
         tests. At this stage the tester instantiates shared state classes of
         the test module, which may potentially cause errors to be signaled. *)
      errors    := Vector new.
      failures  := Vector new.
      successes := Vector new.
      testsPerformed := 0.
      instanceManager createCoreInstances.
    )
    
    public runAllSynchronous = (
      testSuite testCases do: [:case |
        case isAsync ifFalse: [ executeSynchronous: case ] ]
    )
    
    public runAllAsynchronous = (
      | asyncCases |
      asyncCases := testSuite testCases select: [:c | c isAsync ].
      
      ^ actors async: asyncCases do: [:case |
          executeAsynchronous: case ]
    )

    public runAll = (
      prepare.
      runAllSynchronous.
      ^ runAllAsynchronous ensure: [:r | cleanUp ]
    )

    public executeSynchronous: case = (
      (* Execute one test case, add the result to the appropriate collection and
         return it. *)
      | result |
      result := case runUsing: self.
      testsPerformed := testsPerformed + 1.
      result isError   ifTrue: [errors    append: result].
      result isFailure ifTrue: [failures  append: result].
      result isSuccess ifTrue: [successes append: result].
      ^result
    )
    
    public executeAsynchronous: case = (
      (* Execute one test case, add the result to the appropriate collection and
         return it. *)
      | result |
      result := case runUsing: self.
      ^ result whenResolved: [:r |
        testsPerformed := testsPerformed + 1.
        r isError   ifTrue: [errors    append: r].
        r isFailure ifTrue: [failures  append: r].
        r isSuccess ifTrue: [successes append: r].
        r
      ]
    )

    testSuite = (
      ^testSuite_
    )

    public haveAllTestsSucceeded = (
      ^errors size = 0 and: [failures size = 0]
    )

    public peekSelector= (
      (* Returns the selector of the upcoming test case. 
         This message should only be sent if the #atEnd message returns false. *)
      ^ testCaseStream peek selector.
    )

    public runToDebugFailure: testCase = (
      instanceManager createCoreInstancesFor: testCase.
      [testCase runToDebugFailureUsing: self]
        ensure: [cleanUp]
    )

    public runWithNoExceptionHandling: testCase = (
      instanceManager createCoreInstancesFor: testCase.
      [testCase runUnsafeUsing: self]
        ensure: [cleanUp]
    )

    'private'
    public instanceFor: environment = (
      ^instanceManager ensureInstanceFor: environment
    )

  ) : (
    testCatalogs: catalogs = (
      | suite |
      (* Creating a new OrderedCollection is a hack that allows us to use 
         #readStream in case testCases is translated to a Javascript Array *)
      suite := TestSuite testCases: OrderedCollection new.
      catalogs do: [:each | suite := suite ++ each allTests].
      ^self testSuite: suite
    )

    public testModules: modules = (
      ^testCatalogs: (modules collect: [:each | TestCatalog forModule: each])
    )
    
    public testCase: testCase = (
      | suite |
      suite := TestSuite testCases: (Array with: testCase).
      ^ testSuite: suite
    )
  )

  class TopLevelTestEnvironment module: moduleInstance = (
    (* A test environment representing a test module instance. Unlike regular
       TestEnvironments, it has no parents, but otherwise supports much of the
       same protocol. *)
    |
      public moduleInstance = moduleInstance.
      nestedEnvironments = Vector new.
    |
  ) (
    'accessing'
    public addNestedEnvironment: environment = (
      nestedEnvironments append: environment
    )

    'enumerating'
    public parentEnvironmentsDo: aBlock = (
      (* No-op since this is the top level. *)
    )

    public withAllNestedEnvironmentsDo: aBlock = (
      (* Evaluate aBlock with the receiver and all elements of the transitive
         closure of its nested environments (preorder). *)
      aBlock value: self.
      nestedEnvironments do: [:each | each withAllNestedEnvironmentsDo: aBlock]
    )

    public withAllParentEnvironmentsDo: aBlock = (
      (* Evaluate a one-argument block with the receiver and all environment in
         its parent chain, which is to say with the receiver only. *)
      aBlock value: self
    )

    'testing'
    public hasTestCases = (
      (* A top-level test module instance cannot function as a test context
         because it cannot be created and discarded for each test run. *)
      ^ false
    )

    public isRoot = (
      ^ true
    )
  )
)
